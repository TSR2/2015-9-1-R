x=data1[[j]][[i]]$breaks
count=data1[[j]][[i]]$count
minI[,j]=x[exp[,j]]
maxI[,j]=x[exp[,j]+1]
pro=pro*count
}
#獲得主成分的係數向量
coef=hcalcov(data1)[[2]]$vectors
pro
minI
maxI
#判定細數是否小於0，如果小於0，該系數的區間交換大小位置
for (j in 1:p){
if (coef[j,com]<0) {
a=minI[,j]
minI[,j]=maxI[,j]
maxI[,j]=a
}
}
#計算線性組合後的區間
linmin=minI %*% coef[,com]
linmax=maxI %*% coef[,com]
m=cbind(linmin[,1],linmax[,1])
np=as.data.frame(m)
names(np)=c("Imin","Imax")
#找出合併後直方圖的range
his=np %>% summarise(hmin=min(Imin),hmax=max(Imax))
Bi=max(bij)
his=seq(from=his$hmin,to=his$hmax,length.out=Bi+1)
#以下先進行對一個區間重疊的計算
pp=c()
for (b in 1:Bi){
testm=cbind(linmin,linmax,his[b],his[b+1])
#########完全包含的index  有時候會是空的，沒有任何全包含
allcoverindex=(testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |
(testm[,2]>=testm[,4] & testm[,1]<=testm[,3])     #########篩選出完全包含的
allcover=testm[allcoverindex,]
if (is(allcover)[2]=="vector"){
allcover=t(as.matrix(allcover))
}
#計算完全包含的p值
ratio1=min(abs(allcover[,4]-allcover[,3]),abs(allcover[,2]-allcover[,1]))/abs(allcover[,2]-allcover[,1])
p1=sum(ratio1*pro[allcoverindex])
################判斷有重疊的index
coverindex=(testm[,2]>testm[,3] & testm[,1]<testm[,4]) |
(testm[,2]<testm[,3] & testm[,1]>testm[,4])
#######找出有相交，但不是完全包含的index
#######找出有相交，但是不是完全包含的
takem=testm[coverindex,]
if (is(takem)[2]=="vector"){
takem=t(as.matrix(takem))
}
####算出有take重疊的長度
gg=cbind(takem[,2]-takem[,3],takem[,4]-takem[,1])
takelen=apply(abs(gg),1,FUN = min)
ratio2=takelen/abs(takem[,2]-takem[,1])
p2=sum(ratio2*pro[coverindex])
pp[b]=p1+p2
}
ppp[[i]]=pp/sum(pp)
hhh[[i]]=his
}
list(hhh,ppp)
}
dda1=createh(data1=x,com=1)
plotjointh=function(x,b){
dda1=createh(data1=x,com=1)
dda2=createh(data1=x,com=2)
xmax=dda1[[1]] %>% unlist %>% max
xmin=dda1[[1]] %>% unlist %>% min
ymax=dda2[[1]] %>% unlist %>% max
ymin=dda2[[1]] %>% unlist %>% min
xr=seq(xmin,xmax,length.out = b)
yr=seq(ymin,ymax,length.out = b)
lastjoint=matrix(0,ncol=(length(yr)-1),nrow=(length(xr)-1))
part=list()
for (s in 1:length(dda1[[1]])){
b1=list(breaks=dda1[[1]][[s]],counts=dda1[[2]][[s]])
b2=list(breaks=dda2[[1]][[s]],counts=dda2[[2]][[s]])
joint=matrix(0,ncol=(length(yr)-1),nrow=(length(xr)-1))
for (j in 1:(length(yr)-1)){
for (i in 1:(length(xr)-1)){
gg=0
allrange=(xr[i+1]-xr[i])*(yr[j+1]-yr[j])
for(p in 1:length(b1$counts)){
for(k in 1:length(b2$counts)){
aa=min(xr[i+1]-b1$breaks[p],b1$breaks[p+1]-xr[i])
if (aa<0) aa=0
bb=min(yr[j+1]-b2$breaks[k],b2$breaks[k+1]-yr[j])
if (bb<0) bb=0
if (b1$breaks[p]>=xr[i] & b1$breaks[p+1]<=xr[i+1]) aa=b1$breaks[p+1]-b1$breaks[p]
if (b1$breaks[p]<=xr[i] & b1$breaks[p+1]>=xr[i+1]) aa=xr[i+1]-xr[i]
if (b2$breaks[k]>=yr[j] & b2$breaks[k+1]<=yr[j+1]) bb=b2$breaks[k+1]-b2$breaks[k]
if (b2$breaks[k]<=yr[j] & b2$breaks[k+1]>=yr[j+1]) bb=yr[j+1]-yr[j]
coverratio=(aa*bb)/allrange
gg=gg+coverratio*b1$counts[p]*b2$counts[k]
}
}
joint[i,j]=gg
}
}
#part[[s]]=joint
lastjoint=lastjoint+joint
}
image(lastjoint)
}
plotjointh(test4,10)
Rprof()
plotjointh(test4,10)
Rprof(NULL)
summaryRprof()
createh=function(data1,com){
p=length(data1)
n=length(data1[[1]])
ppp=list()
hhh=list()
for (i in 1:n){
bij=c()
b=list()
#算出某個觀測值得每個值方圖資料有幾個分割
for (j in 1:p){
bij[j]=length(data1[[j]][[i]]$count)
b[[j]]=1:bij[j]
}
#造所有區間的組合
exp=expand.grid(b)
#把區間最小值和最大值分別放在不同矩陣(此時只是index)
minI=matrix(0,ncol=p,nrow=dim(exp)[1])
maxI=matrix(0,ncol=p,nrow=dim(exp)[1])
#收集每個區間機率容器
pro=rep(1,dim(exp)[1])
#放入正確的數值
for (j in 1:p){
x=data1[[j]][[i]]$breaks
count=data1[[j]][[i]]$count
minI[,j]=x[exp[,j]]
maxI[,j]=x[exp[,j]+1]
pro=pro*count
}
#獲得主成分的係數向量
coef=hcalcov(data1)[[2]]$vectors
pro
minI
maxI
#判定細數是否小於0，如果小於0，該系數的區間交換大小位置
for (j in 1:p){
if (coef[j,com]<0) {
a=minI[,j]
minI[,j]=maxI[,j]
maxI[,j]=a
}
}
#計算線性組合後的區間
linmin=minI %*% coef[,com]
linmax=maxI %*% coef[,com]
m=cbind(linmin[,1],linmax[,1])
np=as.data.frame(m)
names(np)=c("Imin","Imax")
#找出合併後直方圖的range
his=np %>% summarise(hmin=min(Imin),hmax=max(Imax))
Bi=max(bij)
his=seq(from=his$hmin,to=his$hmax,length.out=Bi+1)
#以下先進行對一個區間重疊的計算
pp=c()
for (b in 1:Bi){
testm=cbind(linmin,linmax,his[b],his[b+1])
#########完全包含的index  有時候會是空的，沒有任何全包含
allcoverindex=which((testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |
(testm[,2]>=testm[,4] & testm[,1]<=testm[,3]))
#########篩選出完全包含的
allcover=testm[allcoverindex,]
if (is(allcover)[2]=="vector"){
allcover=t(as.matrix(allcover))
}
#計算完全包含的p值
ratio1=min(abs(allcover[,4]-allcover[,3]),abs(allcover[,2]-allcover[,1]))/abs(allcover[,2]-allcover[,1])
p1=sum(ratio1*pro[allcoverindex])
################判斷有重疊的index
coverindex=which(testm[,2]>testm[,3] & testm[,1]<testm[,4])
#######找出有相交，但不是完全包含的index
out=coverindex %in% allcoverindex
#######找出有相交，但是不是完全包含的
takeindex=coverindex[!out]
takem=testm[takeindex,]
####算出有take重疊的長度
gg=cbind(takem[,2]-takem[,3],takem[,4]-takem[,1])
takelen=apply(abs(gg),1,FUN = min)
ratio2=takelen/abs(takem[,2]-takem[,1])
p2=sum(ratio2*pro[takeindex])
pp[b]=p1+p2
}
ppp[[i]]=pp/sum(pp)
hhh[[i]]=his
}
list(hhh,ppp)
}
Rprof()
plotjointh(test4,10)
Rprof(NULL)
summaryRprof()
p
t1=t(p) %*% p
eig=eigen(t1)
dr1=p %*% eig$vectors[,1]
dr2=p %*% eig$vectors[,2]
test2=cbind(dr1,dr2)
image(des_e(test2,b=10))
test2
#######################big iris
tt2=function(x){
p=x
for (i in 1:15){
p=rbind(p,p)
}
p
}
big= iris %>% group_by(Species) %>% do(h=tt2(.))
bigtest=do.call(rbind,big$h)
bigtest %>% dim
###############畫出密度估計的圖
test3=bigtest[,1:4]
p=test3 %>% as.matrix()
t1=t(p) %*% p
eig=eigen(t1)
dr1=p %*% eig$vectors[,1]
dr2=p %*% eig$vectors[,2]
test2=cbind(dr1,dr2)
image(des_e(test2,b=10))
t1
tt1
#################畫出密度估計的圖
pp=Sys.time()
test3=bigtest[,1:4]
p=test3 %>% as.matrix()
t1=t(p) %*% p
eig=eigen(t1)
dr1=p %*% eig$vectors[,1]
dr2=p %*% eig$vectors[,2]
test2=cbind(dr1,dr2)
image(des_e(test2,b=10))
tt1=Sys.time()-pp
tt1
m=dim(p)[1]/3
gr=list(1:m,(m+1):(m*2),(2*m+1):(m*3))
par(mfcol=c(3,4))
test4=point_to_h(p,group=gr)
pp=Sys.time()
plotjointh(test4,10)
tt2=Sys.time()-pp
tt2
test4
x=test4
dda1=createh(data1=x,com=1)
test4
Rprof()
pp=Sys.time()
plotjointh(test4,10)
tt2=Sys.time()-pp
tt2
Rprof(NULL)
summaryRprof()
createh=function(data1,com,B=0){
p=length(data1)
n=length(data1[[1]])
ppp=list()
hhh=list()
for (i in 1:n){
bij=c()
b=list()
#算出某個觀測值得每個值方圖資料有幾個分割
for (j in 1:p){
bij[j]=length(data1[[j]][[i]]$count)
b[[j]]=1:bij[j]
}
#造所有區間的組合
exp=expand.grid(b)
#把區間最小值和最大值分別放在不同矩陣(此時只是index)
minI=matrix(0,ncol=p,nrow=dim(exp)[1])
maxI=matrix(0,ncol=p,nrow=dim(exp)[1])
#收集每個區間機率容器
pro=rep(1,dim(exp)[1])
#放入正確的數值
for (j in 1:p){
x=data1[[j]][[i]]$breaks
count=data1[[j]][[i]]$count
minI[,j]=x[exp[,j]]
maxI[,j]=x[exp[,j]+1]
pro=pro*count
}
#獲得主成分的係數向量
coef=hcalcov(data1)[[2]]$vectors
pro
minI
maxI
#判定細數是否小於0，如果小於0，該系數的區間交換大小位置
for (j in 1:p){
if (coef[j,com]<0) {
a=minI[,j]
minI[,j]=maxI[,j]
maxI[,j]=a
}
}
#計算線性組合後的區間
linmin=minI %*% coef[,com]
linmax=maxI %*% coef[,com]
m=cbind(linmin[,1],linmax[,1])
np=as.data.frame(m)
names(np)=c("Imin","Imax")
#找出合併後直方圖的range
his=np %>% summarise(hmin=min(Imin),hmax=max(Imax))
if(B=0) {Bi=max(bij)
}else{Bi=B}
his=seq(from=his$hmin,to=his$hmax,length.out=Bi+1)
#以下先進行對一個區間重疊的計算
pp=c()
for (b in 1:Bi){
testm=cbind(linmin,linmax,his[b],his[b+1])
#########完全包含的index  有時候會是空的，沒有任何全包含
allcoverindex=which((testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |
(testm[,2]>=testm[,4] & testm[,1]<=testm[,3]))
#########篩選出完全包含的
allcover=testm[allcoverindex,]
if (is(allcover)[2]=="vector"){
allcover=t(as.matrix(allcover))
}
#計算完全包含的p值
ratio1=min(abs(allcover[,4]-allcover[,3]),abs(allcover[,2]-allcover[,1]))/abs(allcover[,2]-allcover[,1])
p1=sum(ratio1*pro[allcoverindex])
################判斷有重疊的index
coverindex=which(testm[,2]>testm[,3] & testm[,1]<testm[,4])
#######找出有相交，但不是完全包含的index
out=coverindex %in% allcoverindex
#######找出有相交，但是不是完全包含的
takeindex=coverindex[!out]
takem=testm[takeindex,]
####算出有take重疊的長度
gg=cbind(takem[,2]-takem[,3],takem[,4]-takem[,1])
takelen=apply(abs(gg),1,FUN = min)
ratio2=takelen/abs(takem[,2]-takem[,1])
p2=sum(ratio2*pro[takeindex])
pp[b]=p1+p2
}
ppp[[i]]=pp/sum(pp)
hhh[[i]]=his
}
list(hhh,ppp)
}
createh=function(data1,com,B=0){
p=length(data1)
n=length(data1[[1]])
ppp=list()
hhh=list()
for (i in 1:n){
bij=c()
b=list()
#算出某個觀測值得每個值方圖資料有幾個分割
for (j in 1:p){
bij[j]=length(data1[[j]][[i]]$count)
b[[j]]=1:bij[j]
}
#造所有區間的組合
exp=expand.grid(b)
#把區間最小值和最大值分別放在不同矩陣(此時只是index)
minI=matrix(0,ncol=p,nrow=dim(exp)[1])
maxI=matrix(0,ncol=p,nrow=dim(exp)[1])
#收集每個區間機率容器
pro=rep(1,dim(exp)[1])
#放入正確的數值
for (j in 1:p){
x=data1[[j]][[i]]$breaks
count=data1[[j]][[i]]$count
minI[,j]=x[exp[,j]]
maxI[,j]=x[exp[,j]+1]
pro=pro*count
}
#獲得主成分的係數向量
coef=hcalcov(data1)[[2]]$vectors
pro
minI
maxI
#判定細數是否小於0，如果小於0，該系數的區間交換大小位置
for (j in 1:p){
if (coef[j,com]<0) {
a=minI[,j]
minI[,j]=maxI[,j]
maxI[,j]=a
}
}
#計算線性組合後的區間
linmin=minI %*% coef[,com]
linmax=maxI %*% coef[,com]
m=cbind(linmin[,1],linmax[,1])
np=as.data.frame(m)
names(np)=c("Imin","Imax")
#找出合併後直方圖的range
his=np %>% summarise(hmin=min(Imin),hmax=max(Imax))
if (B==0) {Bi=max(bij)
}else{Bi=B}
his=seq(from=his$hmin,to=his$hmax,length.out=Bi+1)
#以下先進行對一個區間重疊的計算
pp=c()
for (b in 1:Bi){
testm=cbind(linmin,linmax,his[b],his[b+1])
#########完全包含的index  有時候會是空的，沒有任何全包含
allcoverindex=which((testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |
(testm[,2]>=testm[,4] & testm[,1]<=testm[,3]))
#########篩選出完全包含的
allcover=testm[allcoverindex,]
if (is(allcover)[2]=="vector"){
allcover=t(as.matrix(allcover))
}
#計算完全包含的p值
ratio1=min(abs(allcover[,4]-allcover[,3]),abs(allcover[,2]-allcover[,1]))/abs(allcover[,2]-allcover[,1])
p1=sum(ratio1*pro[allcoverindex])
################判斷有重疊的index
coverindex=which(testm[,2]>testm[,3] & testm[,1]<testm[,4])
#######找出有相交，但不是完全包含的index
out=coverindex %in% allcoverindex
#######找出有相交，但是不是完全包含的
takeindex=coverindex[!out]
takem=testm[takeindex,]
####算出有take重疊的長度
gg=cbind(takem[,2]-takem[,3],takem[,4]-takem[,1])
takelen=apply(abs(gg),1,FUN = min)
ratio2=takelen/abs(takem[,2]-takem[,1])
p2=sum(ratio2*pro[takeindex])
pp[b]=p1+p2
}
ppp[[i]]=pp/sum(pp)
hhh[[i]]=his
}
list(hhh,ppp)
}
pp=Sys.time()
plotjointh(test4,10)
tt2=Sys.time()-pp
tt2
pp=Sys.time()
plotjointh(test4,10,8)
tt2=Sys.time()-pp
tt2
plotjointh=function(x,b,...){
dda1=createh(data1=x,com=1,...)
dda2=createh(data1=x,com=2,...)
xmax=dda1[[1]] %>% unlist %>% max
xmin=dda1[[1]] %>% unlist %>% min
ymax=dda2[[1]] %>% unlist %>% max
ymin=dda2[[1]] %>% unlist %>% min
xr=seq(xmin,xmax,length.out = b)
yr=seq(ymin,ymax,length.out = b)
lastjoint=matrix(0,ncol=(length(yr)-1),nrow=(length(xr)-1))
part=list()
for (s in 1:length(dda1[[1]])){
b1=list(breaks=dda1[[1]][[s]],counts=dda1[[2]][[s]])
b2=list(breaks=dda2[[1]][[s]],counts=dda2[[2]][[s]])
joint=matrix(0,ncol=(length(yr)-1),nrow=(length(xr)-1))
for (j in 1:(length(yr)-1)){
for (i in 1:(length(xr)-1)){
gg=0
allrange=(xr[i+1]-xr[i])*(yr[j+1]-yr[j])
for(p in 1:length(b1$counts)){
for(k in 1:length(b2$counts)){
aa=min(xr[i+1]-b1$breaks[p],b1$breaks[p+1]-xr[i])
if (aa<0) aa=0
bb=min(yr[j+1]-b2$breaks[k],b2$breaks[k+1]-yr[j])
if (bb<0) bb=0
if (b1$breaks[p]>=xr[i] & b1$breaks[p+1]<=xr[i+1]) aa=b1$breaks[p+1]-b1$breaks[p]
if (b1$breaks[p]<=xr[i] & b1$breaks[p+1]>=xr[i+1]) aa=xr[i+1]-xr[i]
if (b2$breaks[k]>=yr[j] & b2$breaks[k+1]<=yr[j+1]) bb=b2$breaks[k+1]-b2$breaks[k]
if (b2$breaks[k]<=yr[j] & b2$breaks[k+1]>=yr[j+1]) bb=yr[j+1]-yr[j]
coverratio=(aa*bb)/allrange
gg=gg+coverratio*b1$counts[p]*b2$counts[k]
}
}
joint[i,j]=gg
}
}
#part[[s]]=joint
lastjoint=lastjoint+joint
}
image(lastjoint)
}
plotjointh(test4,10,B=8)
pp=Sys.time()
plotjointh(test4,10,B=8)
tt2=Sys.time()-pp
tt2
rm(list=c('big','bigtest'))
rm(list=c(test3,'bigtest'))
rm(list=c('test3','bigtest'))
rm(list=c('p','test2'))
ls()
Size
?Size
??size
ls.str()
ls.diag()
ls.str(dr1)
environment()
environmentName()
env.profile(dr1)
environment(fun = 1)
environment(fun = 2)
environment(fun = dr1)
memory.size(dr1)
memory.size(gr)
memory.size()
memory.size('fr1')
memory.size('dr1')
memory.size(dr2)
memory.size(aaa)
memory.profile(dr1)
