length(kindex[!out])
kindex[!out]
length(kindex[!out])
?merge
join(c(1,2,3),c(2,3))
library(plyr)
library(dplyr)
library(magrittr)
join(c(1,2,3),c(2,3))
merge(c(1,2,3),c(2,3,4))
merge(c(1,2,3),c(2,3,4),all.x=T)
a=matrix(0,ncol=3,crow=10)
a=matrix(0,ncol=3,nrow=10)
b=matrix(0,ncol=3,nrow=10)
a[,1]=1:10
a[,2]=100
b[,1]=1:10
b[,2]=c(7,8,9)
b
b[,2]=c(7,8)
b
a
merge(a,b)
a=matrix(0,ncol=2,nrow=10)
b=matrix(0,ncol=2,nrow=10)
a=as.data.frame(a)
b=as.data.frame(b)
a[,1]=1:10
a[,2]=100
b[,1]=1:10
b[,2]=c(7,8)
b
a
merge(a,b)
merge(a,b,by="V1")
merge(a,b,all=T)
a=matrix(0,ncol=2,nrow=10)
b=matrix(0,ncol=3,nrow=10)
a=as.data.frame(a)
b=as.data.frame(b)
a[,1]=1:10
a[,2]=100
b[,1]=1:10
b[,2]=c(7,8)
b
a
merge(a,b,all=T)
a=matrix(0,ncol=2,nrow=10)
b=matrix(0,ncol=2,nrow=10)
a=as.data.frame(a)
b=as.data.frame(b)
a[,1]=1:10
a[,2]=100
b[,1]=1:10
b[,2]=c(7,8)
merge(a,b,by="V1",all=T)
merge(a,b)
merge(c(1,2,3),c(1,2))
merge(c(1,2,3),c(1,2),c(7,8,9))
merge(a,b,by.x="V1",by.y="V1")
b[,1]=c(1:5,1:5)
b[,2]=c(7,8)
b
a
merge(a,b,all=T)
b
merge(a,b,all=T)
merge(a,b,by="V1")
merge(a,b,by.x="V1",by.y="V1")
merge(a,b,by="V1",all.x=T)
ff=function(x){
x^2+x+1
}
plot(ff)
ff=function(x,y){
x^2+x+1+y
}
plot(ff)
plot3d(ff)
library(rgl)
plot3d(ff)
ff=function(x,y){
x^2+y^2-1
}
library(rgl)
plot3d(ff)
ff=function(x,y){
sqrt(1-x^2+y^2)
}
library(rgl)
plot3d(ff)
ff=function(x,y){
sqrt(1-x^2-y^2)
}
library(rgl)
plot3d(ff)
plot3d(ff,xlim=c(-1,1),ylim=c(-1,1))
plot3d(ff,xlim=c(-1,1),ylim=c(-1,1),zlim=c(0,1))
plot3d(ff,xlim=c(-1,1),ylim=c(-1,1),zlim=c(-2,2))
plot3d(ff,xlim=c(-1,1),ylim=c(-1,1),zlim=c(-1,1))
plot3d(ff,xlim=c(-1,1),ylim=c(-1,1),zlim=c(-1,1))
plot3d(fff,xlim=c(-1,1),ylim=c(-1,1),zlim=c(-1,1))
ff=function(x,y){
sqrt(1-x^2-y^2)
}
fff=function(x,y){
-sqrt(1-x^2-y^2)
}
plot3d(fff,xlim=c(-1,1),ylim=c(-1,1),zlim=c(-1,1))
plot3d(ff,xlim=c(-1,1),ylim=c(-1,1),zlim=c(-1,1))
library(rgl)
persp3d(ff,xlim=c(-1,1),ylim=c(-1,1),zlim=c(-1,1))
persp3d(fff,xlim=c(-1,1),ylim=c(-1,1),zlim=c(-1,1))
persp3d(ff,xlim=c(-1,1),ylim=c(-1,1),zlim=c(-1,1))
persp3d(fff,xlim=c(-1,1),ylim=c(-1,1),zlim=c(-1,1))
install.packages("plotrix")
??plotrix
library(plotrix)
plotrix(ff)
x=scan("")
integer(1)
integer(2)
integer(0)
x=scan(file="",what=list(name="",pay=integer(0)))
?data.frame
data.frame(n=1:10,p=2:11)
data()
ls()
k=data.frame(n=1:10,p=2:11)
write.table(k,"c:/Users/tsr/Desktop/111.csv",sep=",")
write.table(k,"c:/Users/tsr/Desktop/111.csv",colnames=c("A","b"),sep=",")
write.table(k,"c:/Users/tsr/Desktop/111.csv",col.names=c("A","b"),sep=",")
write.table(k,"c:/Users/tsr/Desktop/111.csv",col.names=c("A","b"),row.names=F,sep=",")
data()
bb=data()
bb
library(data.table)
bb=iris
setDT(bb)
bb
bb=setDT(bb)
bb
?summary
save(bb,"c:/111.Rdata")
save(bb,"c:/111.RData")
save(bb,file="c:/111.RData")
load(file="c:/111.RData")
nn=load(file="c:/111.RData")
bb=iris
save(bb,file="c:/111.RData")
nn=load(file="c:/111.RData")
nn
load(file="c:/111.RData")
rm(bb)
load(file="c:/111.RData")
{a=1:3;x=a+2}
{a=1:3;a+2;a+1}
{a=1:3;x=a+2;xx=a+1}
{a=1:3;x=a+2;xx=a+1}
?switch
switch(a,1="b")
a=c("a","b","c")
switch(a,a="b",b="c")
switch(a,a="b",b="c",c="d")
switch("a",a="b",b="c",c="d")
aa=as.factor(a)
aa
a=c("a","b","c","a")
aa=as.factor(a)
aa
levels(a)[3]="v"
levels(a)[3]=v
levels(aa)[3]="v"
aa
switch(3,a=0,b=3,c=3)
switch(3,0,3,x)
switch(3,0,3,c=3)
a1=c(0,3.5,7.0,10.5,14,17.5,21)
a2=c(3.094,6.5874,6.996,4.1761,1.5798,0.5667)
b1=c(0,4,7,10,13,16,19)
b2=c(4.0833,8.2672,5.1251,3.5680,1.6564,0.3)
c1=c(0,1,2,3,4,5)
c2=c(5.25,9.8,4.2167,2.9,0.8333)
a2=a2/sum(a2)
b2=b2/sum(b2)
c2=c2/sum(c2)
data1=list()
aa=bb=cc=list()
a=list(breaks=a1,count=a2)
class(a)="histogram"
b=list(breaks=b1,count=b2)
class(b)="histogram"
c=list(breaks=c1,count=c2)
class(c)="histogram"
aa[[1]]=a
bb[[1]]=b
cc[[1]]=c
data1[[1]]=aa
data1[[2]]=bb
data1[[3]]=cc
data1[[4]]=aa
data1[[5]]=bb
data1[[6]]=cc
data1
library(plyr)
############################### mean parallel
hcalEX=function(var){
p=length(var)
calEX=function(x){
b=length(x$count)
a=x$count*(x$breaks[2:(b+1)]+x$breaks[1:b])
sum(a)
}
n=length(var[[1]])
mu=c()
for (j in 1:p){
m=sum(sapply(var[[j]],calEX))/(2*n)
mu=c(mu,m)
}
mu
}
##################################var parallel
hcalvar=function(hisvar){
p=length(hisvar)
calEX2=function(x){
b=length(x$count)
parta=x$count*(x$breaks[1:b]^2
+  x$breaks[1:b]*x[[1]][2:(b+1)]
+  x$breaks[2:(b+1)]^2
)
sum(parta)
}
n=length(hisvar[[1]])
EX2=c()
for (j in 1:p){
m=sum(sapply(hisvar[[j]],calEX2))/(3*n)
EX2=c(EX2,m)
}
mu=hcalEX(hisvar)
var=EX2-mu^2
var
}
#########################################calculate covance matrix
hcalcov=function(x){
calEX=function(x){
b=length(x$count)
a=x$count*(x$breaks[2:(b+1)]+x$breaks[1:b])
sum(a)
}
p=length(x)
cov=matrix(0,ncol=p,nrow=p)
for (i in 1:p){
m1=laply(x[[i]],calEX)
for (j in 1:p){
m2=laply(x[[j]],calEX)
cov[i,j]=sum(m1*m2)/(4*p)-sum(m1)*sum(m2)/(4*p^2)
}
}
list(cov,eigen(cov))
}
library(plyr)
library(dplyr)
library(magrittr)
data1
p=6
bij=numeric(p)
for (j in 1:p){
bij[j]=length(data1[[j]][[1]]$count)
}
bij
exp=expand.grid(1:bij[1],1:bij[2],1:bij[3],1:bij[4],1:bij[5],1:bij[6])
#把區間最小值和最大值分別放在不同矩陣(此時只是index)
minI=matrix(0,ncol=p,nrow=dim(exp)[1])
maxI=matrix(0,ncol=p,nrow=dim(exp)[1])
#收集每個區間機率容器
pro=rep(1,dim(exp)[1])
#放入正確的數值
for (j in 1:p){
x=data1[[j]][[1]]$breaks
count=data1[[j]][[1]]$count
minI[,j]=x[exp[,j]]
maxI[,j]=x[exp[,j]+1]
pro=pro*count
}
ver=hcalcov(data1)[[2]]$vectors
pro
minI
maxI
#判定細數是否小於0，如果小於0，該系數的區間交換大小位置
for (i in 1:p){
if (ver[1,i]<0) {
p=minI[,i]
minI[,i]=maxI[,i]
maxI[,i]=p
}
}
#計算線性組合後的區間
linmin=minI %*% ver[1,]
linmax=maxI %*% ver[1,]
m=cbind(linmin[,1],linmax[,1])
np=as.data.frame(m)
names(np)=c("Imin","Imax")
#找出合併後直方圖的range
his=np %>% summarise(hmin=min(Imin),hmax=max(Imax))
Bi=max(bij)
his=seq(from=his$hmin,to=his$hmax,length.out=Bi+1)
testm=cbind(linmin,linmax,his[1],his[2])
###判定是否有重疊
kkk=testm[,2]>testm[,3] & testm[,1]<testm[,4]
sum(kkk)
#########篩選出完全包含的
jjj=(testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |
(testm[,2]>=testm[,4] & testm[,1]<=testm[,3])
allcover=testm[jjj,]
len=cbind(testm[,2]-testm[,3],testm[,4]-testm[,1])
####算出重疊的長度
apply(len,1,FUN = min)
################其他
kindex=which(testm[,2]>testm[,3] & testm[,1]<testm[,4])
##########有相交的index
kindex
jindex=which((testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |
(testm[,2]>=testm[,4] & testm[,1]<=testm[,3]))
#########完全包含的imdex
jindex
out=kindex %in% jindex
kindex[!out]
len=cbind(testm[,2]-testm[,3],testm[,4]-testm[,1])
len
apply(len,1,FUN = min)
apply(abs(len),1,FUN = min)
kindex=which(testm[,2]>testm[,3] & testm[,1]<testm[,4])
length(kindex)
coverindex=which(testm[,2]>testm[,3] & testm[,1]<testm[,4])
#########完全包含的index
allcoverindex=which((testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |
(testm[,2]>=testm[,4] & testm[,1]<=testm[,3]))
out=coverindex %in% allcoverindex
coverindex[!out]
length(coverindex[!out])
takeindex=coverindex[!out]
takem=testm[takeindex,]
####算出重疊的長度
len=cbind(takem[,2]-takem[,3],takem[,4]-takem[,1])
apply(abs(len),1,FUN = min)
allcover
his=np %>% summarise(hmin=min(Imin),hmax=max(Imax))
Bi=max(bij)
his=seq(from=his$hmin,to=his$hmax,length.out=Bi+1)
testm=cbind(linmin,linmax,his[1],his[2])
testm
allcoverlogit=(testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |
(testm[,2]>=testm[,4] & testm[,1]<=testm[,3])
allcover=testm[allcoverlogit,]
allcover
testm
linmin
linmax
linmin
allcover
takem
allcover=testm[allcoverindex,]
allcover
his[1]
his[2]
his
pro
allcover
ratio=min(abs(allcover[,4]-allcover[,3]),abs(allcover[,2]-allcover[,1]))/abs(allcover[,2]-allcover[,1])
ratio*pro[allcoverindex]
sum(ratio*pro[allcoverindex])
gg=cbind(takem[,2]-takem[,3],takem[,4]-takem[,1])
takelen=apply(abs(gg),1,FUN = min)
abs(takem[,2]-takem[,1])
takelen
ratio=takelen/abs(takem[,2]-takem[,1])
sum(ratio*pro[takeindex])
#######找出有相交，但不是完全包含的index
out=coverindex %in% allcoverindex
#######找出有相交，但是不是完全包含的
takeindex=coverindex[!out]
takem=testm[takeindex,]
####算出有take重疊的長度
gg=cbind(takem[,2]-takem[,3],takem[,4]-takem[,1])
takelen=apply(abs(gg),1,FUN = min)
ratio2=takelen/abs(takem[,2]-takem[,1])
p2=sum(ratio2*pro[takeindex])
p2
p1=sum(ratio1*pro[allcoverindex])
#計算完全包含的p值
ratio1=min(abs(allcover[,4]-allcover[,3]),abs(allcover[,2]-allcover[,1]))/abs(allcover[,2]-allcover[,1])
p1=sum(ratio1*pro[allcoverindex])
p1
b=2
testm=cbind(linmin,linmax,his[b],his[b+1])
#########完全包含的index
allcoverindex=which((testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |
(testm[,2]>=testm[,4] & testm[,1]<=testm[,3]))
#########篩選出完全包含的
allcover=testm[allcoverindex,]
#計算完全包含的p值
ratio1=min(abs(allcover[,4]-allcover[,3]),abs(allcover[,2]-allcover[,1]))/abs(allcover[,2]-allcover[,1])
p1=sum(ratio1*pro[allcoverindex])
################判斷有重疊的index
coverindex=which(testm[,2]>testm[,3] & testm[,1]<testm[,4])
#######找出有相交，但不是完全包含的index
out=coverindex %in% allcoverindex
#######找出有相交，但是不是完全包含的
takeindex=coverindex[!out]
takem=testm[takeindex,]
####算出有take重疊的長度
gg=cbind(takem[,2]-takem[,3],takem[,4]-takem[,1])
takelen=apply(abs(gg),1,FUN = min)
ratio2=takelen/abs(takem[,2]-takem[,1])
p2=sum(ratio2*pro[takeindex])
p1
p2
b=3
testm=cbind(linmin,linmax,his[b],his[b+1])
#########完全包含的index
allcoverindex=which((testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |
(testm[,2]>=testm[,4] & testm[,1]<=testm[,3]))
#########篩選出完全包含的
allcover=testm[allcoverindex,]
#計算完全包含的p值
ratio1=min(abs(allcover[,4]-allcover[,3]),abs(allcover[,2]-allcover[,1]))/abs(allcover[,2]-allcover[,1])
p1=sum(ratio1*pro[allcoverindex])
################判斷有重疊的index
coverindex=which(testm[,2]>testm[,3] & testm[,1]<testm[,4])
#######找出有相交，但不是完全包含的index
out=coverindex %in% allcoverindex
#######找出有相交，但是不是完全包含的
takeindex=coverindex[!out]
takem=testm[takeindex,]
####算出有take重疊的長度
gg=cbind(takem[,2]-takem[,3],takem[,4]-takem[,1])
takelen=apply(abs(gg),1,FUN = min)
ratio2=takelen/abs(takem[,2]-takem[,1])
p2=sum(ratio2*pro[takeindex])
p1
p2
b=4
testm=cbind(linmin,linmax,his[b],his[b+1])
#########完全包含的index
allcoverindex=which((testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |
(testm[,2]>=testm[,4] & testm[,1]<=testm[,3]))
#########篩選出完全包含的
allcover=testm[allcoverindex,]
#計算完全包含的p值
ratio1=min(abs(allcover[,4]-allcover[,3]),abs(allcover[,2]-allcover[,1]))/abs(allcover[,2]-allcover[,1])
p1=sum(ratio1*pro[allcoverindex])
################判斷有重疊的index
coverindex=which(testm[,2]>testm[,3] & testm[,1]<testm[,4])
#######找出有相交，但不是完全包含的index
out=coverindex %in% allcoverindex
#######找出有相交，但是不是完全包含的
takeindex=coverindex[!out]
takem=testm[takeindex,]
####算出有take重疊的長度
gg=cbind(takem[,2]-takem[,3],takem[,4]-takem[,1])
takelen=apply(abs(gg),1,FUN = min)
ratio2=takelen/abs(takem[,2]-takem[,1])
p2=sum(ratio2*pro[takeindex])
p1
p2
b=5
testm=cbind(linmin,linmax,his[b],his[b+1])
#########完全包含的index
allcoverindex=which((testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |
(testm[,2]>=testm[,4] & testm[,1]<=testm[,3]))
#########篩選出完全包含的
allcover=testm[allcoverindex,]
#計算完全包含的p值
ratio1=min(abs(allcover[,4]-allcover[,3]),abs(allcover[,2]-allcover[,1]))/abs(allcover[,2]-allcover[,1])
p1=sum(ratio1*pro[allcoverindex])
################判斷有重疊的index
coverindex=which(testm[,2]>testm[,3] & testm[,1]<testm[,4])
#######找出有相交，但不是完全包含的index
out=coverindex %in% allcoverindex
#######找出有相交，但是不是完全包含的
takeindex=coverindex[!out]
takem=testm[takeindex,]
####算出有take重疊的長度
gg=cbind(takem[,2]-takem[,3],takem[,4]-takem[,1])
takelen=apply(abs(gg),1,FUN = min)
ratio2=takelen/abs(takem[,2]-takem[,1])
p2=sum(ratio2*pro[takeindex])
p1
p2
allcover
allcoverindex
library(readxl)
x=read_excel("c:/Users/TSR/Desktop/1041-微積分-20151002.xls")
x
head(x)
x[,3]
dim(x)
x=read_excel("c:/Users/TSR/Desktop/1041-微積分-20151002.xls")
head(x)
dim(x)
x=read_excel("c:/Users/TSR/Desktop/1041-微積分-20151002.xls")
head(x)
x=read.csv("c:/Users/TSR/Desktop/1041-微積分-20151002.csv")
head(x)
dim(x)
head(x)
x[,3]
is(x[,3])
x[,3]=as.character(x[,3])
x[,5]=substr(x[,3],start = 7,stop = 8)
x[,5]
library(plyr)
