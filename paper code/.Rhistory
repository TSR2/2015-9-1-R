ppp[[i]]=pp
hhh[[i]]=his
}
list(ppp,hhh)
}
dda=createh(data1=total,com=1)
kk=hist(iris[,1])
par(mfrow=c(30,1),mai=c(0,0,0,0))
for (i in 1:30){
kk$breaks=dda[[2]][[i]]
kk$counts=dda[[1]][[i]]
plot(kk,xlim=c(-1,6),ylim=c(0,0.5),main="",col="blue")
}
dda=createh(data1=total,com=2)
kk=hist(iris[,1])
par(mfrow=c(30,1),mai=c(0,0,0,0))
for (i in 1:30){
kk$breaks=dda[[2]][[i]]
kk$counts=dda[[1]][[i]]
plot(kk,xlim=c(-1,6),ylim=c(0,0.5),main="",col="blue")
}
dd=list(1:5,1:6,1:3)
max(dd)
tt=laply(dd,max)
tt
tt=laply(dda[[1]],max)
tt
dda=createh(data1=total,com=2)
tt=laply(dda[[1]],max)
tt
dda[[1]]
createh=function(data1,com){
p=length(data1)
n=length(data1[[1]])
for (i in 1:n){
bij=c()
b=list()
for (j in 1:p){
bij[j]=length(data1[[j]][[i]]$count)
b[[j]]=1:bij[j]
}
#造所有區間的組合
exp=expand.grid(b)
#把區間最小值和最大值分別放在不同矩陣(此時只是index)
minI=matrix(0,ncol=p,nrow=dim(exp)[1])
maxI=matrix(0,ncol=p,nrow=dim(exp)[1])
#收集每個區間機率容器
pro=rep(1,dim(exp)[1])
#放入正確的數值
for (j in 1:p){
x=data1[[j]][[i]]$breaks
count=data1[[j]][[i]]$count
minI[,j]=x[exp[,j]]
maxI[,j]=x[exp[,j]+1]
pro=pro*count
}
#獲得主成分的係數向量
coef=hcalcov(data1)[[2]]$vectors
pro
minI
maxI
#判定細數是否小於0，如果小於0，該系數的區間交換大小位置
for (j in 1:p){
if (coef[com,j]<0) {
a=minI[,j]
minI[,j]=maxI[,j]
maxI[,j]=a
}
}
#計算線性組合後的區間
linmin=minI %*% coef[com,]
linmax=maxI %*% coef[com,]
m=cbind(linmin[,1],linmax[,1])
np=as.data.frame(m)
names(np)=c("Imin","Imax")
#找出合併後直方圖的range
his=np %>% summarise(hmin=min(Imin),hmax=max(Imax))
Bi=max(bij)
his=seq(from=his$hmin,to=his$hmax,length.out=Bi+1)
#以下先進行對一個區間重疊的計算
pp=c()
for (b in 1:Bi){
testm=cbind(linmin,linmax,his[b],his[b+1])
#########完全包含的index  有時候會是空的，沒有任何全包含
allcoverindex=which((testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |
(testm[,2]>=testm[,4] & testm[,1]<=testm[,3]))
#########篩選出完全包含的
allcover=testm[allcoverindex,]
if (is(allcover)[2]=="vector"){
allcover=t(as.matrix(allcover))
}
#計算完全包含的p值
ratio1=min(abs(allcover[,4]-allcover[,3]),abs(allcover[,2]-allcover[,1]))/abs(allcover[,2]-allcover[,1])
p1=sum(ratio1*pro[allcoverindex])
################判斷有重疊的index
coverindex=which(testm[,2]>testm[,3] & testm[,1]<testm[,4])
#######找出有相交，但不是完全包含的index
out=coverindex %in% allcoverindex
#######找出有相交，但是不是完全包含的
takeindex=coverindex[!out]
takem=testm[takeindex,]
####算出有take重疊的長度
gg=cbind(takem[,2]-takem[,3],takem[,4]-takem[,1])
takelen=apply(abs(gg),1,FUN = min)
ratio2=takelen/abs(takem[,2]-takem[,1])
p2=sum(ratio2*pro[takeindex])
pp[b]=p1+p2
}
ppp[[i]]=pp
hhh[[i]]=his
}
list(hhh,ppp)
}
dda=createh(data1=total,com=2)
tt=laply(dda[[1]],max)
tt
par(mfrow=c(30,1),mai=c(0,0,0,0))
tt=laply(dda[[1]],max)
mma=max(tt)
tt=laply(dda[[1]],mix)
mmi=mix(tt)
kk=hist(iris[,1])
par(mfrow=c(30,1),mai=c(0,0,0,0))
tt=laply(dda[[1]],max)
bma=max(tt)
tt=laply(dda[[1]],min)
bmi=min(tt)
tt=laply(dda[[2]],max)
pma=max(tt)
tt=laply(dda[[2]],min)
pmi=min(tt)
for (i in 1:30){
kk$breaks=dda[[1]][[i]]
kk$counts=dda[[2]][[i]]
plot(kk,xlim=c(mmi,mma),ylim=c(0,pma),main="",col="blue")
}
par(mfrow=c(30,1),mai=c(0,0,0,0))
tt=laply(dda[[1]],max)
bma=max(tt)
tt=laply(dda[[1]],min)
bmi=min(tt)
tt=laply(dda[[2]],max)
pma=max(tt)
tt=laply(dda[[2]],min)
pmi=min(tt)
for (i in 1:30){
kk$breaks=dda[[1]][[i]]
kk$counts=dda[[2]][[i]]
plot(kk,xlim=c(bmi,bma),ylim=c(0,pma),main="",col="blue")
}
dda=createh(data1=total,com=1)
kk=hist(iris[,1])
par(mfrow=c(30,1),mai=c(0,0,0,0))
tt=laply(dda[[1]],max)
bma=max(tt)
tt=laply(dda[[1]],min)
bmi=min(tt)
tt=laply(dda[[2]],max)
pma=max(tt)
tt=laply(dda[[2]],min)
pmi=min(tt)
for (i in 1:30){
kk$breaks=dda[[1]][[i]]
kk$counts=dda[[2]][[i]]
plot(kk,xlim=c(bmi,bma),ylim=c(0,pma),main="",col="blue")
}
bmi
for (i in 1:30){
kk$breaks=dda[[1]][[i]]
kk$counts=dda[[2]][[i]]
plot(kk,xlim=c(bmi-1,bma+1),ylim=c(0,pma),main="",col="blue")
}
bmi
bmi-1
for (i in 1:30){
kk$breaks=dda[[1]][[i]]
kk$counts=dda[[2]][[i]]
plot(kk,xlim=c(-1,bma+1),ylim=c(0,pma),main="",col="blue")
}
for (i in 1:30){
kk$breaks=dda[[1]][[i]]
kk$counts=dda[[2]][[i]]
plot(kk,xlim=c(bmi-1,bma+1),ylim=c(0,pma),main="",col="blue")
}
for (i in 1:30){
kk$breaks=dda[[1]][[i]]
kk$counts=dda[[2]][[i]]
plot(kk,xlim=c(-3,bma+1),ylim=c(0,pma),main="",col="blue")
}
for (i in 1:30){
kk$breaks=dda[[1]][[i]]
kk$counts=dda[[2]][[i]]
plot(kk,xlim=c(bmi-2,bma+1),ylim=c(0,pma),main="",col="blue")
}
createh=function(data1,com){
p=length(data1)
n=length(data1[[1]])
for (i in 1:n){
bij=c()
b=list()
for (j in 1:p){
bij[j]=length(data1[[j]][[i]]$count)
b[[j]]=1:bij[j]
}
#造所有區間的組合
exp=expand.grid(b)
#把區間最小值和最大值分別放在不同矩陣(此時只是index)
minI=matrix(0,ncol=p,nrow=dim(exp)[1])
maxI=matrix(0,ncol=p,nrow=dim(exp)[1])
#收集每個區間機率容器
pro=rep(1,dim(exp)[1])
#放入正確的數值
for (j in 1:p){
x=data1[[j]][[i]]$breaks
count=data1[[j]][[i]]$count
minI[,j]=x[exp[,j]]
maxI[,j]=x[exp[,j]+1]
pro=pro*count
}
#獲得主成分的係數向量
coef=hcalcov(data1)[[2]]$vectors
pro
minI
maxI
#判定細數是否小於0，如果小於0，該系數的區間交換大小位置
for (j in 1:p){
if (coef[com,j]<0) {
a=minI[,j]
minI[,j]=maxI[,j]
maxI[,j]=a
}
}
#計算線性組合後的區間
linmin=minI %*% coef[com,]
linmax=maxI %*% coef[com,]
m=cbind(linmin[,1],linmax[,1])
np=as.data.frame(m)
names(np)=c("Imin","Imax")
#找出合併後直方圖的range
his=np %>% summarise(hmin=min(Imin),hmax=max(Imax))
Bi=max(bij)
his=seq(from=his$hmin,to=his$hmax,length.out=Bi+1)
#以下先進行對一個區間重疊的計算
pp=c()
for (b in 1:Bi){
testm=cbind(linmin,linmax,his[b],his[b+1])
#########完全包含的index  有時候會是空的，沒有任何全包含
allcoverindex=which((testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |
(testm[,2]>=testm[,4] & testm[,1]<=testm[,3]))
#########篩選出完全包含的
allcover=testm[allcoverindex,]
if (is(allcover)[2]=="vector"){
allcover=t(as.matrix(allcover))
}
#計算完全包含的p值
ratio1=min(abs(allcover[,4]-allcover[,3]),abs(allcover[,2]-allcover[,1]))/abs(allcover[,2]-allcover[,1])
p1=sum(ratio1*pro[allcoverindex])
################判斷有重疊的index
coverindex=which(testm[,2]>testm[,3] & testm[,1]<testm[,4])
#######找出有相交，但不是完全包含的index
out=coverindex %in% allcoverindex
#######找出有相交，但是不是完全包含的
takeindex=coverindex[!out]
takem=testm[takeindex,]
####算出有take重疊的長度
gg=cbind(takem[,2]-takem[,3],takem[,4]-takem[,1])
takelen=apply(abs(gg),1,FUN = min)
ratio2=takelen/abs(takem[,2]-takem[,1])
p2=sum(ratio2*pro[takeindex])
pp[b]=p1+p2
}
ppp[[i]]=pp
hhh[[i]]=his
}
list(hhh,ppp)
}
dda=createh(data1=total,com=1)
kk=hist(iris[,1])
par(mfrow=c(30,2),mai=c(0,0,0,0))
tt=laply(dda[[1]],max)
bma=max(tt)
tt=laply(dda[[1]],min)
bmi=min(tt)
tt=laply(dda[[2]],max)
pma=max(tt)
tt=laply(dda[[2]],min)
pmi=min(tt)
for (i in 1:30){
kk$breaks=dda[[1]][[i]]
kk$counts=dda[[2]][[i]]
plot(kk,xlim=c(bmi-2,bma+1),ylim=c(0,pma),main="",col="blue")
}
?par
dda=createh(data1=total,com=1)
kk=hist(iris[,1])
par(mfcol=c(30,2),mai=c(0,0,0,0))
tt=laply(dda[[1]],max)
bma=max(tt)
tt=laply(dda[[1]],min)
bmi=min(tt)
tt=laply(dda[[2]],max)
pma=max(tt)
tt=laply(dda[[2]],min)
pmi=min(tt)
for (i in 1:30){
kk$breaks=dda[[1]][[i]]
kk$counts=dda[[2]][[i]]
plot(kk,xlim=c(bmi-2,bma+1),ylim=c(0,pma),main="",col="blue")
}
dda=createh(data1=total,com=2)
kk=hist(iris[,1])
par(mfcol=c(30,2),mai=c(0,0,0,0))
tt=laply(dda[[1]],max)
bma=max(tt)
tt=laply(dda[[1]],min)
bmi=min(tt)
tt=laply(dda[[2]],max)
pma=max(tt)
tt=laply(dda[[2]],min)
pmi=min(tt)
for (i in 1:30){
kk$breaks=dda[[1]][[i]]
kk$counts=dda[[2]][[i]]
plot(kk,xlim=c(bmi-2,bma+1),ylim=c(0,pma),main="",col="blue")
}
dda=createh(data1=total,com=1)
kk=hist(iris[,1])
tt=laply(dda[[1]],max)
bma=max(tt)
tt=laply(dda[[1]],min)
bmi=min(tt)
tt=laply(dda[[2]],max)
pma=max(tt)
tt=laply(dda[[2]],min)
pmi=min(tt)
for (i in 1:30){
kk$breaks=dda[[1]][[i]]
kk$counts=dda[[2]][[i]]
plot(kk,xlim=c(bmi-2,bma+1),ylim=c(0,pma),main="",col="blue")
}
par(mfcol=c(30,2),mai=c(0,0,0,0))
dda=createh(data1=total,com=1)
kk=hist(iris[,1])
tt=laply(dda[[1]],max)
bma=max(tt)
tt=laply(dda[[1]],min)
bmi=min(tt)
tt=laply(dda[[2]],max)
pma=max(tt)
tt=laply(dda[[2]],min)
pmi=min(tt)
for (i in 1:30){
kk$breaks=dda[[1]][[i]]
kk$counts=dda[[2]][[i]]
plot(kk,xlim=c(bmi-2,bma+1),ylim=c(0,pma),main="",col="blue")
}
(kk=hist(iris[,1]))
par(mfcol=c(30,2),mai=c(0,0,0,0))
dda=createh(data1=total,com=1)
(kk=hist(iris[,1]))
tt=laply(dda[[1]],max)
bma=max(tt)
tt=laply(dda[[1]],min)
bmi=min(tt)
tt=laply(dda[[2]],max)
pma=max(tt)
tt=laply(dda[[2]],min)
pmi=min(tt)
for (i in 1:30){
kk$breaks=dda[[1]][[i]]
kk$counts=dda[[2]][[i]]
plot(kk,xlim=c(bmi-2,bma+1),ylim=c(0,pma),main="",col="blue")
}
par(mfcol=c(30,2),mai=c(0,0,0,0))
dda=createh(data1=total,com=1)
(kk=hist(iris[,1]))
tt=laply(dda[[1]],max)
bma=max(tt)
tt=laply(dda[[1]],min)
bmi=min(tt)
tt=laply(dda[[2]],max)
pma=max(tt)
tt=laply(dda[[2]],min)
pmi=min(tt)
for (i in 1:30){
kk$breaks=dda[[1]][[i]]
kk$counts=dda[[2]][[i]]
plot(kk,xlim=c(bmi-2,bma+1),ylim=c(0,pma),main="",col="blue")
}
par(mfcol=c(30,2),mai=c(0,0,0,0))
dda=createh(data1=total,com=1)
tt=laply(dda[[1]],max)
bma=max(tt)
tt=laply(dda[[1]],min)
bmi=min(tt)
tt=laply(dda[[2]],max)
pma=max(tt)
tt=laply(dda[[2]],min)
pmi=min(tt)
for (i in 1:30){
kk$breaks=dda[[1]][[i]]
kk$counts=dda[[2]][[i]]
plot(kk,xlim=c(bmi-2,bma+1),ylim=c(0,pma),main="",col="blue")
}
dda=createh(data1=total,com=2)
tt=laply(dda[[1]],max)
bma=max(tt)
tt=laply(dda[[1]],min)
bmi=min(tt)
tt=laply(dda[[2]],max)
pma=max(tt)
tt=laply(dda[[2]],min)
pmi=min(tt)
for (i in 1:30){
kk$breaks=dda[[1]][[i]]
kk$counts=dda[[2]][[i]]
plot(kk,xlim=c(bmi-2,bma+1),ylim=c(0,pma),main="",col="blue")
}
for (i in 1:30){
kk$breaks=dda[[1]][[i]]
kk$counts=dda[[2]][[i]]
plot(kk,xlim=c(bmi-2,bma+1),ylim=c(0,pma),main="",col="blue",ylab = "")
}
for (i in 1:30){
kk$breaks=dda[[1]][[i]]
kk$counts=dda[[2]][[i]]
plot(kk,xlim=c(bmi-2,bma+1),ylim=c(0,pma),main="",col="blue",ylab = "")
}
g=matrix(1:25,ncol=5)
g=matrix(1:25,ncol=5)
image(g)
image(g,add = T)
image(g,col = heat.colors(12),
breaks, horiz=TRUE, ylim=NULL, xlim=NULL)
image(g,col = heat.colors(12), horiz=TRUE, ylim=NULL, xlim=NULL)
image.plot(g,col = heat.colors(12), horiz=TRUE, ylim=NULL, xlim=NULL)
image(g,col = heat.colors(12))
points(x=0:100,y=rep(1,101),col=heat.colors(101),pch=15,cex=2)
image.scale <- function(z, zlim, col = heat.colors(12),
breaks, axis.pos=1, add.axis=TRUE, ...){
if(!missing(breaks)){
if(length(breaks) != (length(col)+1)){stop("must have one more break than colour")}
}
if(missing(breaks) & !missing(zlim)){
breaks <- seq(zlim[1], zlim[2], length.out=(length(col)+1))
}
if(missing(breaks) & missing(zlim)){
zlim <- range(z, na.rm=TRUE)
zlim[2] <- zlim[2]+c(zlim[2]-zlim[1])*(1E-3)#adds a bit to the range in both directions
zlim[1] <- zlim[1]-c(zlim[2]-zlim[1])*(1E-3)
breaks <- seq(zlim[1], zlim[2], length.out=(length(col)+1))
}
poly <- vector(mode="list", length(col))
for(i in seq(poly)){
poly[[i]] <- c(breaks[i], breaks[i+1], breaks[i+1], breaks[i])
}
if(axis.pos %in% c(1,3)){ylim<-c(0,1); xlim<-range(breaks)}
if(axis.pos %in% c(2,4)){ylim<-range(breaks); xlim<-c(0,1)}
plot(1,1,t="n",ylim=ylim, xlim=xlim, axes=FALSE, xlab="", ylab="", xaxs="i", yaxs="i", ...)
for(i in seq(poly)){
if(axis.pos %in% c(1,3)){
polygon(poly[[i]], c(0,0,1,1), col=col[i], border=NA)
}
if(axis.pos %in% c(2,4)){
polygon(c(0,0,1,1), poly[[i]], col=col[i], border=NA)
}
}
box()
if(add.axis) {axis(axis.pos)}
}
breaks <- seq(min(volcano), max(volcano),length.out=100)
par(mar=c(1,1,1,1))
image(seq(dim(volcano)[1]), seq(dim(volcano)[2]), volcano,
col=pal.1(length(breaks)-1), breaks=breaks-1e-8, xaxt="n", yaxt="n", ylab="", xlab="")
#Add additional graphics
levs <- pretty(range(volcano), 5)
contour(seq(dim(volcano)[1]), seq(dim(volcano)[2]), volcano, levels=levs, add=TRUE)
#Add scale
par(mar=c(3,1,1,1))
image.scale(volcano, col=pal.1(length(breaks)-1), breaks=breaks-1e-8,axis.pos=1)
abline(v=levs)
image.scale(x, col=pal.1(length(breaks)-1), breaks=breaks-1e-8,axis.pos=1)
image.scale(g, col=pal.1(length(breaks)-1), breaks=breaks-1e-8,axis.pos=1)
abline(v=levs)
image.scale(g, col=pal.1(length(breaks)-1),
breaks=breaks-1e-8,axis.pos=1)
getwd
getwd()
dda
dda1=createh(data1=total,com=1)
library(plyr)
library(dplyr)
library(magrittr)
dda1=createh(data1=total,com=1)
dda2=createh(data1=total,com=1)
dd=c(dda1,dda2)
dd
xx=-2:6
xx=-2:6
yy=seq(0,1,0.2)
dd[[1]][[1]]
dd[[1]][[1]]
b1=dd[[1]][[1]]
p1=dd[[2]][[1]]
b2=dd[[3]][[1]]
p2=dd[[4]][[1]]
outer(p1,p2)
mm=outer(p1,p2)
image(mm)
xx=-2:6
yy=-2:6
expand.grid(xx,yy)
