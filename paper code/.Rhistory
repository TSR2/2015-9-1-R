out=coverindex %in% allcoverindex
#######找出有相交，但是不是完全包含的
takeindex=coverindex[!out]
takem=testm[takeindex,]
####算出有take重疊的長度
gg=cbind(takem[,2]-takem[,3],takem[,4]-takem[,1])
takelen=apply(abs(gg),1,FUN = min)
ratio2=takelen/abs(takem[,2]-takem[,1])
p2=sum(ratio2*pro[takeindex])
pp[b]=p1+p2
}
ppp[[i]]=pp
}
ppp
ppp=list()
data1=total
p=7
n=30
for (i in 1:30){
bij=c()
for (j in 1:p){
bij[j]=length(data1[[j]][[i]]$count)
}
bij
#造所有區間的組合
exp=expand.grid(1:bij[1],1:bij[2],1:bij[3],1:bij[4],1:bij[5],1:bij[6],1:bij[7])
#把區間最小值和最大值分別放在不同矩陣(此時只是index)
minI=matrix(0,ncol=p,nrow=dim(exp)[1])
maxI=matrix(0,ncol=p,nrow=dim(exp)[1])
#收集每個區間機率容器
pro=rep(1,dim(exp)[1])
#放入正確的數值
for (j in 1:p){
x=data1[[j]][[i]]$breaks
count=data1[[j]][[i]]$count
minI[,j]=x[exp[,j]]
maxI[,j]=x[exp[,j]+1]
pro=pro*count
}
#獲得主成分的係數向量
coef=hcalcov(data1)[[2]]$vectors
pro
minI
maxI
#判定細數是否小於0，如果小於0，該系數的區間交換大小位置
for (j in 1:p){
if (coef[1,j]<0) {
a=minI[,j]
minI[,j]=maxI[,j]
maxI[,j]=a
}
}
#計算線性組合後的區間
linmin=minI %*% coef[1,]
linmax=maxI %*% coef[1,]
m=cbind(linmin[,1],linmax[,1])
np=as.data.frame(m)
names(np)=c("Imin","Imax")
#找出合併後直方圖的range
his=np %>% summarise(hmin=min(Imin),hmax=max(Imax))
Bi=max(bij)
his=seq(from=his$hmin,to=his$hmax,length.out=Bi+1)
#以下先進行對一個區間重疊的計算
pp=c()
for (b in 1:Bi){
testm=cbind(linmin,linmax,his[b],his[b+1])
#########完全包含的index  有時候會是空的，沒有任何全包含
allcoverindex=which((testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |
(testm[,2]>=testm[,4] & testm[,1]<=testm[,3]))
#########篩選出完全包含的
allcover=testm[allcoverindex,]
#計算完全包含的p值
ratio1=min(abs(allcover[,4]-allcover[,3]),abs(allcover[,2]-allcover[,1]))/abs(allcover[,2]-allcover[,1])
p1=sum(ratio1*pro[allcoverindex])
################判斷有重疊的index
coverindex=which(testm[,2]>testm[,3] & testm[,1]<testm[,4])
#######找出有相交，但不是完全包含的index
out=coverindex %in% allcoverindex
#######找出有相交，但是不是完全包含的
takeindex=coverindex[!out]
takem=testm[takeindex,]
####算出有take重疊的長度
gg=cbind(takem[,2]-takem[,3],takem[,4]-takem[,1])
takelen=apply(abs(gg),1,FUN = min)
ratio2=takelen/abs(takem[,2]-takem[,1])
p2=sum(ratio2*pro[takeindex])
pp[b]=p1+p2
}
ppp[[i]]=pp
}
ppp
allcover[,4]
allcover[,4]
testm
allcoverindex
allcoverindex=which((testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |
(testm[,2]>=testm[,4] & testm[,1]<=testm[,3]))
allcoverindex
testm[allcoverindex,]
allcover
(allcover[,4]
)
allcover[,4]
allcover=as.matrix(allcover)
allcover
allcover=testm[allcoverindex,]
is(allcover)
is(allcover)[2]=="vector"
allcover=t(as.matrix(allcover)
)
allcover
ppp=list()
data1=total
p=7
n=30
for (i in 1:30){
bij=c()
for (j in 1:p){
bij[j]=length(data1[[j]][[i]]$count)
}
bij
#造所有區間的組合
exp=expand.grid(1:bij[1],1:bij[2],1:bij[3],1:bij[4],1:bij[5],1:bij[6],1:bij[7])
#把區間最小值和最大值分別放在不同矩陣(此時只是index)
minI=matrix(0,ncol=p,nrow=dim(exp)[1])
maxI=matrix(0,ncol=p,nrow=dim(exp)[1])
#收集每個區間機率容器
pro=rep(1,dim(exp)[1])
#放入正確的數值
for (j in 1:p){
x=data1[[j]][[i]]$breaks
count=data1[[j]][[i]]$count
minI[,j]=x[exp[,j]]
maxI[,j]=x[exp[,j]+1]
pro=pro*count
}
#獲得主成分的係數向量
coef=hcalcov(data1)[[2]]$vectors
pro
minI
maxI
#判定細數是否小於0，如果小於0，該系數的區間交換大小位置
for (j in 1:p){
if (coef[1,j]<0) {
a=minI[,j]
minI[,j]=maxI[,j]
maxI[,j]=a
}
}
#計算線性組合後的區間
linmin=minI %*% coef[1,]
linmax=maxI %*% coef[1,]
m=cbind(linmin[,1],linmax[,1])
np=as.data.frame(m)
names(np)=c("Imin","Imax")
#找出合併後直方圖的range
his=np %>% summarise(hmin=min(Imin),hmax=max(Imax))
Bi=max(bij)
his=seq(from=his$hmin,to=his$hmax,length.out=Bi+1)
#以下先進行對一個區間重疊的計算
pp=c()
for (b in 1:Bi){
testm=cbind(linmin,linmax,his[b],his[b+1])
#########完全包含的index  有時候會是空的，沒有任何全包含
allcoverindex=which((testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |
(testm[,2]>=testm[,4] & testm[,1]<=testm[,3]))
#########篩選出完全包含的
allcover=testm[allcoverindex,]
if (is(allcover)[2]=="vector"){
allcover=t(as.matrix(allcover))
}
#計算完全包含的p值
ratio1=min(abs(allcover[,4]-allcover[,3]),abs(allcover[,2]-allcover[,1]))/abs(allcover[,2]-allcover[,1])
p1=sum(ratio1*pro[allcoverindex])
################判斷有重疊的index
coverindex=which(testm[,2]>testm[,3] & testm[,1]<testm[,4])
#######找出有相交，但不是完全包含的index
out=coverindex %in% allcoverindex
#######找出有相交，但是不是完全包含的
takeindex=coverindex[!out]
takem=testm[takeindex,]
####算出有take重疊的長度
gg=cbind(takem[,2]-takem[,3],takem[,4]-takem[,1])
takelen=apply(abs(gg),1,FUN = min)
ratio2=takelen/abs(takem[,2]-takem[,1])
p2=sum(ratio2*pro[takeindex])
pp[b]=p1+p2
}
ppp[[i]]=pp
}
ppp
View(testm)
View(testm)
a=list()
total=list()
for (j in 1:6){
for (i in 1:30){
his <- hist(iris[sample(x=1:150,50),1])
his$counts <- his$counts/sum(his$counts)
a[[i]] <- his
}
total[[j]] <- a
}
library(plyr)
############################### mean parallel
hcalEX=function(var){
p=length(var)
calEX=function(x){
b=length(x$count)
a=x$count*(x$breaks[2:(b+1)]+x$breaks[1:b])
sum(a)
}
n=length(var[[1]])
mu=c()
for (j in 1:p){
m=sum(sapply(var[[j]],calEX))/(2*n)
mu=c(mu,m)
}
mu
}
##################################var parallel
hcalvar=function(hisvar){
p=length(hisvar)
calEX2=function(x){
b=length(x$count)
parta=x$count*(x$breaks[1:b]^2
+  x$breaks[1:b]*x[[1]][2:(b+1)]
+  x$breaks[2:(b+1)]^2
)
sum(parta)
}
n=length(hisvar[[1]])
EX2=c()
for (j in 1:p){
m=sum(sapply(hisvar[[j]],calEX2))/(3*n)
EX2=c(EX2,m)
}
mu=hcalEX(hisvar)
var=EX2-mu^2
var
}
#########################################calculate covance matrix
hcalcov=function(x){
calEX=function(x){
b=length(x$count)
a=x$count*(x$breaks[2:(b+1)]+x$breaks[1:b])
sum(a)
}
p=length(x)
cov=matrix(0,ncol=p,nrow=p)
for (i in 1:p){
m1=laply(x[[i]],calEX)
for (j in 1:p){
m2=laply(x[[j]],calEX)
cov[i,j]=sum(m1*m2)/(4*p)-sum(m1)*sum(m2)/(4*p^2)
}
}
list(cov,eigen(cov))
}
ppp=list()
data1=total
p=6
n=30
for (i in 1:30){
bij=c()
for (j in 1:p){
bij[j]=length(data1[[j]][[i]]$count)
}
bij
#造所有區間的組合
exp=expand.grid(1:bij[1],1:bij[2],1:bij[3],1:bij[4],1:bij[5],1:bij[6])
#把區間最小值和最大值分別放在不同矩陣(此時只是index)
minI=matrix(0,ncol=p,nrow=dim(exp)[1])
maxI=matrix(0,ncol=p,nrow=dim(exp)[1])
#收集每個區間機率容器
pro=rep(1,dim(exp)[1])
#放入正確的數值
for (j in 1:p){
x=data1[[j]][[i]]$breaks
count=data1[[j]][[i]]$count
minI[,j]=x[exp[,j]]
maxI[,j]=x[exp[,j]+1]
pro=pro*count
}
#獲得主成分的係數向量
coef=hcalcov(data1)[[2]]$vectors
pro
minI
maxI
#判定細數是否小於0，如果小於0，該系數的區間交換大小位置
for (j in 1:p){
if (coef[1,j]<0) {
a=minI[,j]
minI[,j]=maxI[,j]
maxI[,j]=a
}
}
#計算線性組合後的區間
linmin=minI %*% coef[1,]
linmax=maxI %*% coef[1,]
m=cbind(linmin[,1],linmax[,1])
np=as.data.frame(m)
names(np)=c("Imin","Imax")
#找出合併後直方圖的range
his=np %>% summarise(hmin=min(Imin),hmax=max(Imax))
Bi=max(bij)
his=seq(from=his$hmin,to=his$hmax,length.out=Bi+1)
#以下先進行對一個區間重疊的計算
pp=c()
for (b in 1:Bi){
testm=cbind(linmin,linmax,his[b],his[b+1])
#########完全包含的index  有時候會是空的，沒有任何全包含
allcoverindex=which((testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |
(testm[,2]>=testm[,4] & testm[,1]<=testm[,3]))
#########篩選出完全包含的
allcover=testm[allcoverindex,]
if (is(allcover)[2]=="vector"){
allcover=t(as.matrix(allcover))
}
#計算完全包含的p值
ratio1=min(abs(allcover[,4]-allcover[,3]),abs(allcover[,2]-allcover[,1]))/abs(allcover[,2]-allcover[,1])
p1=sum(ratio1*pro[allcoverindex])
################判斷有重疊的index
coverindex=which(testm[,2]>testm[,3] & testm[,1]<testm[,4])
#######找出有相交，但不是完全包含的index
out=coverindex %in% allcoverindex
#######找出有相交，但是不是完全包含的
takeindex=coverindex[!out]
takem=testm[takeindex,]
####算出有take重疊的長度
gg=cbind(takem[,2]-takem[,3],takem[,4]-takem[,1])
takelen=apply(abs(gg),1,FUN = min)
ratio2=takelen/abs(takem[,2]-takem[,1])
p2=sum(ratio2*pro[takeindex])
pp[b]=p1+p2
}
ppp[[i]]=pp
}
ppp
library(plyr)
library(dplyr)
library(magrittr)
ppp=list()
data1=total
p=6
n=30
for (i in 1:30){
bij=c()
for (j in 1:p){
bij[j]=length(data1[[j]][[i]]$count)
}
bij
#造所有區間的組合
exp=expand.grid(1:bij[1],1:bij[2],1:bij[3],1:bij[4],1:bij[5],1:bij[6])
#把區間最小值和最大值分別放在不同矩陣(此時只是index)
minI=matrix(0,ncol=p,nrow=dim(exp)[1])
maxI=matrix(0,ncol=p,nrow=dim(exp)[1])
#收集每個區間機率容器
pro=rep(1,dim(exp)[1])
#放入正確的數值
for (j in 1:p){
x=data1[[j]][[i]]$breaks
count=data1[[j]][[i]]$count
minI[,j]=x[exp[,j]]
maxI[,j]=x[exp[,j]+1]
pro=pro*count
}
#獲得主成分的係數向量
coef=hcalcov(data1)[[2]]$vectors
pro
minI
maxI
#判定細數是否小於0，如果小於0，該系數的區間交換大小位置
for (j in 1:p){
if (coef[1,j]<0) {
a=minI[,j]
minI[,j]=maxI[,j]
maxI[,j]=a
}
}
#計算線性組合後的區間
linmin=minI %*% coef[1,]
linmax=maxI %*% coef[1,]
m=cbind(linmin[,1],linmax[,1])
np=as.data.frame(m)
names(np)=c("Imin","Imax")
#找出合併後直方圖的range
his=np %>% summarise(hmin=min(Imin),hmax=max(Imax))
Bi=max(bij)
his=seq(from=his$hmin,to=his$hmax,length.out=Bi+1)
#以下先進行對一個區間重疊的計算
pp=c()
for (b in 1:Bi){
testm=cbind(linmin,linmax,his[b],his[b+1])
#########完全包含的index  有時候會是空的，沒有任何全包含
allcoverindex=which((testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |
(testm[,2]>=testm[,4] & testm[,1]<=testm[,3]))
#########篩選出完全包含的
allcover=testm[allcoverindex,]
if (is(allcover)[2]=="vector"){
allcover=t(as.matrix(allcover))
}
#計算完全包含的p值
ratio1=min(abs(allcover[,4]-allcover[,3]),abs(allcover[,2]-allcover[,1]))/abs(allcover[,2]-allcover[,1])
p1=sum(ratio1*pro[allcoverindex])
################判斷有重疊的index
coverindex=which(testm[,2]>testm[,3] & testm[,1]<testm[,4])
#######找出有相交，但不是完全包含的index
out=coverindex %in% allcoverindex
#######找出有相交，但是不是完全包含的
takeindex=coverindex[!out]
takem=testm[takeindex,]
####算出有take重疊的長度
gg=cbind(takem[,2]-takem[,3],takem[,4]-takem[,1])
takelen=apply(abs(gg),1,FUN = min)
ratio2=takelen/abs(takem[,2]-takem[,1])
p2=sum(ratio2*pro[takeindex])
pp[b]=p1+p2
}
ppp[[i]]=pp
}
ppp
a=list()
total=list()
for (j in 1:4){
for (i in 1:30){
his <- hist(iris[sample(x=1:150,50),j])
his$counts <- his$counts/sum(his$counts)
a[[i]] <- his
}
total[[j]] <- a
}
ppp=list()
data1=total
p=4
n=30
for (i in 1:30){
bij=c()
for (j in 1:p){
bij[j]=length(data1[[j]][[i]]$count)
}
bij
#造所有區間的組合
exp=expand.grid(1:bij[1],1:bij[2],1:bij[3],1:bij[4])
#把區間最小值和最大值分別放在不同矩陣(此時只是index)
minI=matrix(0,ncol=p,nrow=dim(exp)[1])
maxI=matrix(0,ncol=p,nrow=dim(exp)[1])
#收集每個區間機率容器
pro=rep(1,dim(exp)[1])
#放入正確的數值
for (j in 1:p){
x=data1[[j]][[i]]$breaks
count=data1[[j]][[i]]$count
minI[,j]=x[exp[,j]]
maxI[,j]=x[exp[,j]+1]
pro=pro*count
}
#獲得主成分的係數向量
coef=hcalcov(data1)[[2]]$vectors
pro
minI
maxI
#判定細數是否小於0，如果小於0，該系數的區間交換大小位置
for (j in 1:p){
if (coef[1,j]<0) {
a=minI[,j]
minI[,j]=maxI[,j]
maxI[,j]=a
}
}
#計算線性組合後的區間
linmin=minI %*% coef[1,]
linmax=maxI %*% coef[1,]
m=cbind(linmin[,1],linmax[,1])
np=as.data.frame(m)
names(np)=c("Imin","Imax")
#找出合併後直方圖的range
his=np %>% summarise(hmin=min(Imin),hmax=max(Imax))
Bi=max(bij)
his=seq(from=his$hmin,to=his$hmax,length.out=Bi+1)
#以下先進行對一個區間重疊的計算
pp=c()
for (b in 1:Bi){
testm=cbind(linmin,linmax,his[b],his[b+1])
#########完全包含的index  有時候會是空的，沒有任何全包含
allcoverindex=which((testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |
(testm[,2]>=testm[,4] & testm[,1]<=testm[,3]))
#########篩選出完全包含的
allcover=testm[allcoverindex,]
if (is(allcover)[2]=="vector"){
allcover=t(as.matrix(allcover))
}
#計算完全包含的p值
ratio1=min(abs(allcover[,4]-allcover[,3]),abs(allcover[,2]-allcover[,1]))/abs(allcover[,2]-allcover[,1])
p1=sum(ratio1*pro[allcoverindex])
################判斷有重疊的index
coverindex=which(testm[,2]>testm[,3] & testm[,1]<testm[,4])
#######找出有相交，但不是完全包含的index
out=coverindex %in% allcoverindex
#######找出有相交，但是不是完全包含的
takeindex=coverindex[!out]
takem=testm[takeindex,]
####算出有take重疊的長度
gg=cbind(takem[,2]-takem[,3],takem[,4]-takem[,1])
takelen=apply(abs(gg),1,FUN = min)
ratio2=takelen/abs(takem[,2]-takem[,1])
p2=sum(ratio2*pro[takeindex])
pp[b]=p1+p2
}
ppp[[i]]=pp
}
ppp
