m=dim(p)[1]/3
gr=list(1:m,(m+1):(m*2),(2*m+1):(m*3))
par(mfcol=c(3,4))
test4=point_to_h(p,group=gr)
pp=Sys.time()
createh(data1 = test4,com=1)
tt2=Sys.time()-pp
tt2
createh=function(data1,com,B=0){
p=length(data1)
n=length(data1[[1]])
ppp=list()
hhh=list()
for (i in 1:n){
bij=c()
b=list()
#算出某個觀測值得每個值方圖資料有幾個分割
for (j in 1:p){
bij[j]=length(data1[[j]][[i]]$count)
b[[j]]=1:bij[j]
}
#造所有區間的組合
exp=expand.grid(b)
#把區間最小值和最大值分別放在不同矩陣(此時只是index)
minI=matrix(0,ncol=p,nrow=dim(exp)[1])
maxI=matrix(0,ncol=p,nrow=dim(exp)[1])
#收集每個區間機率容器
pro=rep(1,dim(exp)[1])
#放入正確的數值
for (j in 1:p){
x=data1[[j]][[i]]$breaks
count=data1[[j]][[i]]$count
minI[,j]=x[exp[,j]]
maxI[,j]=x[exp[,j]+1]
pro=pro*count
}
#獲得主成分的係數向量
coef=hcalcov(data1)[[2]]$vectors
pro
minI
maxI
#判定細數是否小於0，如果小於0，該系數的區間交換大小位置
for (j in 1:p){
if (coef[j,com]<0) {
a=minI[,j]
minI[,j]=maxI[,j]
maxI[,j]=a
}
}
#計算線性組合後的區間
linmin=minI %*% coef[,com]
linmax=maxI %*% coef[,com]
m=cbind(linmin[,1],linmax[,1])
np=as.data.frame(m)
names(np)=c("Imin","Imax")
#找出合併後直方圖的range
his=np %>% summarise(hmin=min(Imin),hmax=max(Imax))
if (B==0) {Bi=max(bij)
}else{Bi=B}
his=seq(from=his$hmin,to=his$hmax,length.out=Bi+1)
#以下先進行對一個區間重疊的計算
pp=c()
for (b in 1:Bi){
testm=cbind(linmin,linmax,his[b],his[b+1])
#########完全包含的index  有時候會是空的，沒有任何全包含
allcoverindex=which((testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |
(testm[,2]>=testm[,4] & testm[,1]<=testm[,3]))
#########篩選出完全包含的
allcover=testm[allcoverindex,]
if (is(allcover)[2]=="vector"){
allcover=t(as.matrix(allcover))
}
#計算完全包含的p值
ratio1=min(abs(allcover[,4]-allcover[,3]),abs(allcover[,2]-allcover[,1]))/abs(allcover[,2]-allcover[,1])
p1=sum(ratio1*pro[allcoverindex])
################判斷有重疊的index
coverindex=which(testm[,2]>testm[,3] & testm[,1]<testm[,4])
#######找出有相交，但不是完全包含的index
out=coverindex %in% allcoverindex
#######找出有相交，但是不是完全包含的
takeindex=coverindex[!out]
takem=testm[takeindex,]
####算出有take重疊的長度
gg=cbind(takem[,2]-takem[,3],takem[,4]-takem[,1])
takelen=apply(abs(gg),1,FUN = min)
ratio2=takelen/abs(takem[,2]-takem[,1])
p2=sum(ratio2*pro[takeindex])
pp[b]=p1+p2
}
ppp[[i]]=pp/sum(pp)
hhh[[i]]=his
}
list(hhh,ppp)
}
pp=Sys.time()
createh(data1 = test4,com=1)
tt2=Sys.time()-pp
tt2
Rprof()
createh(data1 = test4,com=1)
Rprof(NULL)
summaryRprof()
createh=function(data1,com,B=0){
p=length(data1)
n=length(data1[[1]])
ppp=list()
hhh=list()
for (i in 1:n){
bij=c()
b=list()
#算出某個觀測值得每個值方圖資料有幾個分割
for (j in 1:p){
bij[j]=length(data1[[j]][[i]]$count)
b[[j]]=1:bij[j]
}
#造所有區間的組合
exp=expand.grid(b)
#把區間最小值和最大值分別放在不同矩陣(此時只是index)
minI=matrix(0,ncol=p,nrow=dim(exp)[1])
maxI=matrix(0,ncol=p,nrow=dim(exp)[1])
#收集每個區間機率容器
pro=rep(1,dim(exp)[1])
#放入正確的數值
for (j in 1:p){
x=data1[[j]][[i]]$breaks
count=data1[[j]][[i]]$count
minI[,j]=x[exp[,j]]
maxI[,j]=x[exp[,j]+1]
pro=pro*count
}
#獲得主成分的係數向量
coef=hcalcov(data1)[[2]]$vectors
pro
minI
maxI
#判定細數是否小於0，如果小於0，該系數的區間交換大小位置
for (j in 1:p){
if (coef[j,com]<0) {
a=minI[,j]
minI[,j]=maxI[,j]
maxI[,j]=a
}
}
#計算線性組合後的區間
linmin=minI %*% coef[,com]
linmax=maxI %*% coef[,com]
m=cbind(linmin[,1],linmax[,1])
np=as.data.frame(m)
names(np)=c("Imin","Imax")
#找出合併後直方圖的range
his=np %>% summarise(hmin=min(Imin),hmax=max(Imax))
if (B==0) {Bi=max(bij)
}else{Bi=B}
his=seq(from=his$hmin,to=his$hmax,length.out=Bi+1)
#以下先進行對一個區間重疊的計算
pp=rep(0,Bi)
for (b in 1:Bi){
testm=cbind(linmin,linmax,his[b],his[b+1])
#########完全包含的index  有時候會是空的，沒有任何全包含
allcoverindex=which((testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |
(testm[,2]>=testm[,4] & testm[,1]<=testm[,3]))
#########篩選出完全包含的
allcover=testm[allcoverindex,]
if (is(allcover)[2]=="vector"){
allcover=t(as.matrix(allcover))
}
#計算完全包含的p值
if(dim(allcover)[1]>0){
ratio1=min(abs(allcover[,4]-allcover[,3]),abs(allcover[,2]-allcover[,1]))/abs(allcover[,2]-allcover[,1])
p1=sum(ratio1*pro[allcoverindex])
}else{p1=0}
################判斷有重疊的index
coverindex=which(testm[,2]>testm[,3] & testm[,1]<testm[,4])
#######找出有相交，但不是完全包含的index
out=coverindex %in% allcoverindex
#######找出有相交，但是不是完全包含的
takeindex=coverindex[!out]
takem=testm[takeindex,]
####算出有take重疊的長度
if(dim(takem)[1]>0){
gg=data.frame(a=takem[,2]-takem[,3],b=takem[,4]-takem[,1])
takelen=gg %>% select(h=min(a,b))
ratio2=takelen/abs(takem[,2]-takem[,1])
p2=sum(ratio2*pro[takeindex])
}else{p2=0}
pp[b]=p1+p2
}
ppp[[i]]=pp/sum(pp)
hhh[[i]]=his
}
list(hhh,ppp)
}
Rprof()
createh(data1 = test4,com=1)
Rprof(NULL)
summaryRprof()
Sys.time()
proc.time()
pp=proc.time()
createh(data1 = test4,com=1)
tt2=proc.time()-pp
tt2
createh=function(data1,com,B=0){
p=length(data1)
n=length(data1[[1]])
ppp=list()
hhh=list()
for (i in 1:n){
bij=c()
b=list()
#算出某個觀測值得每個值方圖資料有幾個分割
for (j in 1:p){
bij[j]=length(data1[[j]][[i]]$count)
b[[j]]=1:bij[j]
}
#造所有區間的組合
exp=expand.grid(b)
#把區間最小值和最大值分別放在不同矩陣(此時只是index)
minI=matrix(0,ncol=p,nrow=dim(exp)[1])
maxI=matrix(0,ncol=p,nrow=dim(exp)[1])
#收集每個區間機率容器
pro=rep(1,dim(exp)[1])
#放入正確的數值
for (j in 1:p){
x=data1[[j]][[i]]$breaks
count=data1[[j]][[i]]$count
minI[,j]=x[exp[,j]]
maxI[,j]=x[exp[,j]+1]
pro=pro*count
}
#獲得主成分的係數向量
coef=hcalcov(data1)[[2]]$vectors
pro
minI
maxI
#判定細數是否小於0，如果小於0，該系數的區間交換大小位置
for (j in 1:p){
if (coef[j,com]<0) {
a=minI[,j]
minI[,j]=maxI[,j]
maxI[,j]=a
}
}
#計算線性組合後的區間
linmin=minI %*% coef[,com]
linmax=maxI %*% coef[,com]
m=cbind(linmin[,1],linmax[,1])
np=as.data.frame(m)
names(np)=c("Imin","Imax")
#找出合併後直方圖的range
his=np %>% summarise(hmin=min(Imin),hmax=max(Imax))
if (B==0) {Bi=max(bij)
}else{Bi=B}
his=seq(from=his$hmin,to=his$hmax,length.out=Bi+1)
#以下先進行對一個區間重疊的計算
pp=c()
for (b in 1:Bi){
testm=cbind(linmin,linmax,his[b],his[b+1])
#########完全包含的index  有時候會是空的，沒有任何全包含
allcoverindex=which((testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |
(testm[,2]>=testm[,4] & testm[,1]<=testm[,3]))
#########篩選出完全包含的
allcover=testm[allcoverindex,]
if (is(allcover)[2]=="vector"){
allcover=t(as.matrix(allcover))
}
#計算完全包含的p值
ratio1=min(abs(allcover[,4]-allcover[,3]),abs(allcover[,2]-allcover[,1]))/abs(allcover[,2]-allcover[,1])
p1=sum(ratio1*pro[allcoverindex])
################判斷有重疊的index
coverindex=which(testm[,2]>testm[,3] & testm[,1]<testm[,4])
#######找出有相交，但不是完全包含的index
out=coverindex %in% allcoverindex
#######找出有相交，但是不是完全包含的
takeindex=coverindex[!out]
takem=testm[takeindex,]
####算出有take重疊的長度
gg=cbind(takem[,2]-takem[,3],takem[,4]-takem[,1])
takelen=apply(abs(gg),1,FUN = min)
ratio2=takelen/abs(takem[,2]-takem[,1])
p2=sum(ratio2*pro[takeindex])
pp[b]=p1+p2
}
ppp[[i]]=pp/sum(pp)
hhh[[i]]=his
}
list(hhh,ppp)
}
pp=proc.time()
createh(data1 = test4,com=1)
tt2=proc.time()-pp
tt2
createh=function(data1,com,B=0){
p=length(data1)
n=length(data1[[1]])
ppp=list()
hhh=list()
for (i in 1:n){
bij=c()
b=list()
#算出某個觀測值得每個值方圖資料有幾個分割
for (j in 1:p){
bij[j]=length(data1[[j]][[i]]$count)
b[[j]]=1:bij[j]
}
#造所有區間的組合
exp=expand.grid(b)
#把區間最小值和最大值分別放在不同矩陣(此時只是index)
minI=matrix(0,ncol=p,nrow=dim(exp)[1])
maxI=matrix(0,ncol=p,nrow=dim(exp)[1])
#收集每個區間機率容器
pro=rep(1,dim(exp)[1])
#放入正確的數值
for (j in 1:p){
x=data1[[j]][[i]]$breaks
count=data1[[j]][[i]]$count
minI[,j]=x[exp[,j]]
maxI[,j]=x[exp[,j]+1]
pro=pro*count
}
#獲得主成分的係數向量
coef=hcalcov(data1)[[2]]$vectors
pro
minI
maxI
#判定細數是否小於0，如果小於0，該系數的區間交換大小位置
for (j in 1:p){
if (coef[j,com]<0) {
a=minI[,j]
minI[,j]=maxI[,j]
maxI[,j]=a
}
}
#計算線性組合後的區間
linmin=minI %*% coef[,com]
linmax=maxI %*% coef[,com]
np=data.frame(Imin=linmin[,1],Imax=linmax[,1])
#找出合併後直方圖的range
his=np %>% summarise(hmin=min(Imin),hmax=max(Imax))
if (B==0) {Bi=max(bij)
}else{Bi=B}
his=seq(from=his$hmin,to=his$hmax,length.out=Bi+1)
#以下先進行對一個區間重疊的計算
pp=rep(0,Bi)
for (b in 1:Bi){
testm=cbind(linmin,linmax,his[b],his[b+1])
#########完全包含的index  有時候會是空的，沒有任何全包含
allcoverindex=which((testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |
(testm[,2]>=testm[,4] & testm[,1]<=testm[,3]))
#########篩選出完全包含的
allcover=testm[allcoverindex,]
if (is(allcover)[2]=="vector"){
allcover=t(as.matrix(allcover))
}
#計算完全包含的p值
if(dim(allcover)[1]>0){
ratio1=min(abs(allcover[,4]-allcover[,3]),abs(allcover[,2]-allcover[,1]))/abs(allcover[,2]-allcover[,1])
p1=sum(ratio1*pro[allcoverindex])
}else{p1=0}
################判斷有重疊的index
coverindex=which(testm[,2]>testm[,3] & testm[,1]<testm[,4])
#######找出有相交，但不是完全包含的index
out=coverindex %in% allcoverindex
#######找出有相交，但是不是完全包含的
takeindex=coverindex[!out]
takem=testm[takeindex,]
####算出有take重疊的長度
if(dim(takem)[1]>0){
gg=data.frame(a=takem[,2]-takem[,3],b=takem[,4]-takem[,1])
takelen=gg %>% select(h=min(a,b))
ratio2=takelen/abs(takem[,2]-takem[,1])
p2=sum(ratio2*pro[takeindex])
}else{p2=0}
pp[b]=p1+p2
}
ppp[[i]]=pp/sum(pp)
hhh[[i]]=his
}
list(hhh,ppp)
}
pp=proc.time()
createh(data1 = test4,com=1)
tt2=proc.time()-pp
tt2
createh=function(data1,com,B=0){
p=length(data1)
n=length(data1[[1]])
ppp=list()
hhh=list()
for (i in 1:n){
bij=c()
b=list()
#算出某個觀測值得每個值方圖資料有幾個分割
for (j in 1:p){
bij[j]=length(data1[[j]][[i]]$count)
b[[j]]=1:bij[j]
}
#造所有區間的組合
exp=expand.grid(b)
#把區間最小值和最大值分別放在不同矩陣(此時只是index)
minI=matrix(0,ncol=p,nrow=dim(exp)[1])
maxI=matrix(0,ncol=p,nrow=dim(exp)[1])
#收集每個區間機率容器
pro=rep(1,dim(exp)[1])
#放入正確的數值
for (j in 1:p){
x=data1[[j]][[i]]$breaks
count=data1[[j]][[i]]$count
minI[,j]=x[exp[,j]]
maxI[,j]=x[exp[,j]+1]
pro=pro*count
}
#獲得主成分的係數向量
coef=hcalcov(data1)[[2]]$vectors
#判定細數是否小於0，如果小於0，該系數的區間交換大小位置
for (j in 1:p){
if (coef[j,com]<0) {
a=minI[,j]
minI[,j]=maxI[,j]
maxI[,j]=a
}
}
#計算線性組合後的區間
linmin=minI %*% coef[,com]
linmax=maxI %*% coef[,com]
#找出合併後直方圖的range
if (B==0) {Bi=max(bij)
}else{Bi=B}
his=seq(from=min(linmin[,1]),to=max(linmax[,1]),length.out=Bi+1)
#以下先進行對一個區間重疊的計算
pp=rep(0,Bi)
for (b in 1:Bi){
testm=cbind(linmin,linmax,his[b],his[b+1])
#########完全包含的index  有時候會是空的，沒有任何全包含
allcoverindex=which((testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |
(testm[,2]>=testm[,4] & testm[,1]<=testm[,3]))
#########篩選出完全包含的
allcover=testm[allcoverindex,]
if (is(allcover)[2]=="vector"){
allcover=t(as.matrix(allcover))
}
#計算完全包含的p值
if(dim(allcover)[1]>0){
ratio1=min(abs(allcover[,4]-allcover[,3]),abs(allcover[,2]-allcover[,1]))/abs(allcover[,2]-allcover[,1])
p1=sum(ratio1*pro[allcoverindex])
}else{p1=0}
################判斷有重疊的index
coverindex=which(testm[,2]>testm[,3] & testm[,1]<testm[,4])
#######找出有相交，但不是完全包含的index
out=coverindex %in% allcoverindex
#######找出有相交，但是不是完全包含的
takeindex=coverindex[!out]
takem=testm[takeindex,]
####算出有take重疊的長度
if(dim(takem)[1]>0){
gg=data.frame(a=takem[,2]-takem[,3],b=takem[,4]-takem[,1])
takelen=gg %>% select(h=min(a,b))
ratio2=takelen/abs(takem[,2]-takem[,1])
p2=sum(ratio2*pro[takeindex])
}else{p2=0}
pp[b]=p1+p2
}
ppp[[i]]=pp/sum(pp)
hhh[[i]]=his
}
list(hhh,ppp)
}
pp=proc.time()
createh(data1 = test4,com=1)
tt2=proc.time()-pp
tt2
pp=proc.time()
createh(data1 = test4,com=1)
tt2=proc.time()-pp
tt2
pp=proc.time()
createh(data1 = test4,com=1)
tt2=proc.time()-pp
tt2
pp=proc.time()
createh(data1 = test4,com=1)
tt2=proc.time()-pp
tt2
a1=read.table('data_banknote_authentication.txt',sep=',')
a1 %>% head
test3=a1[,1:4]
#test3=iris[,1:4]
par(mfrow=c(1,1))
p=test3 %>% as.matrix()
t1=t(p) %*% p
eig=eigen(t1)
#plot(p %*% eig$vectors[,2],p %*% eig$vectors[,1],col=a1$V5+1)
p=test3 %>% as.matrix()
t1=t(p) %*% p
eig=eigen(t1)
dr1=p %*% eig$vectors[,1]
dr2=p %*% eig$vectors[,2]
test2=cbind(dr1,dr2)
image(des_e(test2,b=10))
gr=list(which(a1$V5==0),which(a1$V5==1))
test4=point_to_h(p,group=gr)
plotjointh(test4,10,B=10)
#############################kmean
test1=kmeans(test3,centers = 2)
tt1=test1$cluster
gr=list(which(tt1==1),which(tt1==2))
test4=point_to_h(p,group=gr)
plotjointh(test4,10,B=10)
rm(list=bigtest)
rm(list=c(bigtest))
rm(list=c('bigtest'))
rm(list=c('big'))
