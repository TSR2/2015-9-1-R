{
    "contents" : "library(plyr)\nlibrary(dplyr)\nlibrary(magrittr)\n\n#####################?H?????ͪ????ϸ???\na=list()\ntotal=list()\nfor (j in 1:4){\n  for (i in 1:30){\n    range1=switch ((i %/% 11)+1,1:50,51:100,101:150) \n    his <- hist(iris[sample(x=range1,20),j])\n    his$counts <- his$counts/sum(his$counts)\n    a[[i]] <- his\n  }\n  total[[j]] <- a\n}\n######################################?ۦP??????\na=list()\ntotal=list()\nfor (j in 1:7){\n  for (i in 1:30){\n    his <- hist(iris[,1])\n    his$counts <- his$counts/sum(his$counts)\n    a[[i]] <- his\n  }\n  total[[j]] <- a\n}\ntt=proc.time()\ndda=createh(data1=total,com=j)\nproc.time()-tt\n\n##################?e??????\npar(mfrow=c(6,4),mai=c(0,0,0,0))\nfor (j in 1:4){\n  for (i in 1:30){\n    plot(total[[j]][[i]],main = \"\",xlab = \"\",ylab = \"\")\n  }\n}\nhis\nlength(total[[1]][[1]][[1]])\n\n#########################?⥭?? for\n\nmu=c()\nfor (j in 1:3){\n  sum=0\n  for (i in 1:1){\n    for (b in 1:(length(total[[j]][[i]][[1]])-1)){\n      a=total[[j]][[i]][[2]][b]*(total[[j]][[i]][[1]][b+1]+total[[j]][[i]][[1]][b])\n    sum=a+sum\n    }\n  }\n  mu=c(mu,sum/(2*i))\n}\nmu\n########################?⥭??  ?V?q\n\nmu=c()\nfor (j in 1:4){\n  sum=0\n  for (i in 1:30){\n    b=length(total[[j]][[i]][[1]])-1\n    a=total[[j]][[i]][[2]]*(total[[j]][[i]][[1]][2:(b+1)]+total[[j]][[i]][[1]][1:b])\n    sum=sum+sum(a)\n  }\n  mu=c(mu,sum/(2*i))\n}\nmu\n\n##################################mean parallel\n\nhcalEX=function(var){\n  p=length(var)\n  calEX=function(x){\n    b=length(x$count)\n    a=x$count*(x$breaks[2:(b+1)]+x$breaks[1:b])\n    sum(a)\n  }\n  n=length(var[[1]])\n  mu=c()\n  for (j in 1:p){\n    m=sum(sapply(var[[j]],calEX))/(2*n)\n    mu=c(mu,m)\n  }\n  mu\n}\n##################################var parallel\nhcalvar=function(hisvar){\n  p=length(hisvar)\n  calEX2=function(x){\n    b=length(x$count)\n    parta=x$count*(x$breaks[1:b]^2  \n                  +  x$breaks[1:b]*x[[1]][2:(b+1)]  \n                  +  x$breaks[2:(b+1)]^2\n                  )\n    sum(parta)\n  }\n  n=length(hisvar[[1]])\n  EX2=c()\n  for (j in 1:p){\n    m=sum(sapply(hisvar[[j]],calEX2))/(3*n)\n    EX2=c(EX2,m)\n  }\n  EX2\n  mu=hcalEX(hisvar)\n  var=EX2-mu^2\n  var\n}\n\n################################################ var for\nEX2=c()\nfor (j in 1:1){\n  sum=0\n  for (i in 1:1){\n    b=length(total[[j]][[i]][[1]])-1\n    a=total[[j]][[i]][[2]]*(total[[j]][[i]][[1]][2:(b+1)]^2+\n                              total[[j]][[i]][[1]][2:(b+1)]*total[[j]][[i]][[1]][1:b]+\n                              total[[j]][[i]][[1]][1:b]^2)\n    sum=sum+sum(a)\n  }\n  EX2=c(EX2,sum/(3*i))\n}\nEX2\nvar=EX2-mu^2\nvar\n###############################################covrance\n\nhcalcov=function(x){\n  p=length(x)\n  cov=matrix(0,ncol=p,nrow=p)\n  for (i in 1:p){\n    m1=laply(x[[i]],calEX)\n    for (j in 1:p){\n      m2=laply(x[[j]],calEX)\n      cov[i,j]=sum(m1*m2)/(4*p)-sum(m1)*sum(m2)/(4*p^2)\n    }\n  }\n  list(cov,eigen(cov))\n}\n\n\n########################################\n##linear combin\nppp=list()\nhhh=list()\ndata1=total\n\n\ncreateh=function(data1,com){\n  p=length(data1)\n  n=length(data1[[1]])\n  for (i in 1:n){\n    bij=c()\n    b=list()\n    for (j in 1:p){\n      bij[j]=length(data1[[j]][[i]]$count)\n      b[[j]]=1:bij[j]\n    }\n    #造所有區間的組合\n    exp=expand.grid(b)\n    #把區間最小值和最大值分別放在不同矩陣(此時只是index)\n    minI=matrix(0,ncol=p,nrow=dim(exp)[1])\n    maxI=matrix(0,ncol=p,nrow=dim(exp)[1])\n    #收集每個區間機率容器\n    pro=rep(1,dim(exp)[1])\n    #放入正確的數值\n    for (j in 1:p){\n      x=data1[[j]][[i]]$breaks\n      count=data1[[j]][[i]]$count\n      minI[,j]=x[exp[,j]]\n      maxI[,j]=x[exp[,j]+1]\n      pro=pro*count\n    }\n    #獲得主成分的係數向量\n    coef=hcalcov(data1)[[2]]$vectors\n    pro\n    minI\n    maxI\n    #判定細數是否小於0，如果小於0，該系數的區間交換大小位置\n    for (j in 1:p){\n      if (coef[com,j]<0) {\n        a=minI[,j]\n        minI[,j]=maxI[,j]\n        maxI[,j]=a\n      }\n    }\n    \n    #計算線性組合後的區間\n    linmin=minI %*% coef[com,]\n    linmax=maxI %*% coef[com,]\n    m=cbind(linmin[,1],linmax[,1])\n    \n    np=as.data.frame(m)\n    names(np)=c(\"Imin\",\"Imax\")\n    #找出合併後直方圖的range\n    his=np %>% summarise(hmin=min(Imin),hmax=max(Imax))\n    Bi=max(bij)\n    his=seq(from=his$hmin,to=his$hmax,length.out=Bi+1)\n    \n  \n    #以下先進行對一個區間重疊的計算\n    pp=c()\n    for (b in 1:Bi){\n      testm=cbind(linmin,linmax,his[b],his[b+1])\n      \n      #########完全包含的index  有時候會是空的，沒有任何全包含\n      allcoverindex=which((testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |\n                            (testm[,2]>=testm[,4] & testm[,1]<=testm[,3]))\n      #########篩選出完全包含的\n      allcover=testm[allcoverindex,]\n      if (is(allcover)[2]==\"vector\"){\n        allcover=t(as.matrix(allcover))\n      }\n      #計算完全包含的p值\n      ratio1=min(abs(allcover[,4]-allcover[,3]),abs(allcover[,2]-allcover[,1]))/abs(allcover[,2]-allcover[,1])\n      p1=sum(ratio1*pro[allcoverindex])\n      \n      ################判斷有重疊的index\n      coverindex=which(testm[,2]>testm[,3] & testm[,1]<testm[,4])\n      #######找出有相交，但不是完全包含的index\n      out=coverindex %in% allcoverindex\n      #######找出有相交，但是不是完全包含的\n      takeindex=coverindex[!out]\n      takem=testm[takeindex,]\n      ####算出有take重疊的長度\n      gg=cbind(takem[,2]-takem[,3],takem[,4]-takem[,1])\n      takelen=apply(abs(gg),1,FUN = min)\n      \n      ratio2=takelen/abs(takem[,2]-takem[,1])\n      p2=sum(ratio2*pro[takeindex])\n      pp[b]=p1+p2\n    }\n  ppp[[i]]=pp\n  hhh[[i]]=his\n  }\n  list(hhh,ppp)\n}\n\n\n\n\n\n\n\nfor (j in 1:2){\n  if(j==1) {\n    par(mfcol=c(30,2),mai=c(0,0,0,0))\n    kk=hist(iris[,1],plot=F)\n  }\n  dda=createh(data1=total,com=j)\n  tt=laply(dda[[1]],max)\n  bma=max(tt)\n  tt=laply(dda[[1]],min)\n  bmi=min(tt)\n  tt=laply(dda[[2]],max)\n  pma=max(tt)\n  tt=laply(dda[[2]],min)\n  pmi=min(tt)\n  for (i in 1:30){\n    kk$breaks=dda[[1]][[i]]\n    kk$counts=dda[[2]][[i]]\n    plot(kk,xlim=c(bmi-2,bma+1),ylim=c(0,pma),main=\"\",col=\"blue\",ylab = \"\")\n  }\n}\n\n\ndd=c(dda1,dda2)\nxx=-2:6\nyy=-2:6\n\nfor (i in 1:30){  \n  b1=dd[[1]][[1]]\n  p1=dd[[2]][[1]]\n  b2=dd[[3]][[1]]\n  p2=dd[[4]][[1]]\n  mm=outer(p1,p2)\n  expand.grid(xx,yy)\n  for (i in 1:(length(b1)-1)){\n    for (j in 1:){\n      \n    }\n  }\n  image(mm)\n}\ng=matrix(1:25,ncol=5)\nimage(g,col = heat.colors(12))\npoints(x=0:100,y=rep(1,101),col=heat.colors(101),pch=15,cex=2) \n",
    "created" : 1447172335608.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4144465332",
    "id" : "ADA952FE",
    "lastKnownWriteTime" : 1447177423,
    "path" : "~/GitHub/2015-9-1-R/paper code/paper.R",
    "project_path" : "paper.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}