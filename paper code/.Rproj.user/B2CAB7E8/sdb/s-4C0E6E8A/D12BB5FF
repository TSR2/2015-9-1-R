{
    "contents" : "library(plyr)\nlibrary(dplyr)\nlibrary(magrittr)\n\n############################### mean parallel \nhcalEX=function(var){\n  p=length(var)\n  calEX=function(x){\n    b=length(x$count)\n    a=x$count*(x$breaks[2:(b+1)]+x$breaks[1:b])\n    sum(a)\n  }\n  n=length(var[[1]])\n  mu=c()\n  for (j in 1:p){\n    m=sum(sapply(var[[j]],calEX))/(2*n)\n    mu=c(mu,m)\n  }\n  mu\n}\n##################################var parallel\nhcalvar=function(hisvar){\n  p=length(hisvar)\n  calEX2=function(x){\n    b=length(x$count)\n    parta=x$count*(x$breaks[1:b]^2  \n                   +  x$breaks[1:b]*x[[1]][2:(b+1)]  \n                   +  x$breaks[2:(b+1)]^2\n    )\n    sum(parta)\n  }\n  n=length(hisvar[[1]])\n  EX2=c()\n  for (j in 1:p){\n    m=sum(sapply(hisvar[[j]],calEX2))/(3*n)\n    EX2=c(EX2,m)\n  }\n  mu=hcalEX(hisvar)\n  var=EX2-mu^2\n  var\n}\n#########################################calculate covance matrix\nhcalcov=function(x){\n  calEX=function(x){\n    b=length(x$count)\n    a=x$count*(x$breaks[2:(b+1)]+x$breaks[1:b])\n    sum(a)\n  }\n  p=length(x)\n  cov=matrix(0,ncol=p,nrow=p)\n  for (i in 1:p){\n    m1=laply(x[[i]],calEX)\n    for (j in 1:p){\n      m2=laply(x[[j]],calEX)\n      cov[i,j]=sum(m1*m2)/(4*p)-sum(m1)*sum(m2)/(4*p^2)\n    }\n  }\n  list(cov,eigen(cov))\n}\n\n\n#########################create compo hist\ncreateh=function(data1,com,B=0){\n  p=length(data1)\n  n=length(data1[[1]])\n  ppp=list()\n  hhh=list()\n  for (i in 1:n){\n    bij=c()\n    b=list()\n    #算出某個觀測值得每個值方圖資料有幾個分割\n    for (j in 1:p){\n      bij[j]=length(data1[[j]][[i]]$count)\n      b[[j]]=1:bij[j]\n    }\n    #造所有區間的組合\n    exp=expand.grid(b)\n    #把區間最小值和最大值分別放在不同矩陣(此時只是index)\n    minI=matrix(0,ncol=p,nrow=dim(exp)[1])\n    maxI=matrix(0,ncol=p,nrow=dim(exp)[1])\n    #收集每個區間機率容器\n    pro=rep(1,dim(exp)[1])\n    #放入正確的數值\n    for (j in 1:p){\n      x=data1[[j]][[i]]$breaks\n      count=data1[[j]][[i]]$count\n      minI[,j]=x[exp[,j]]\n      maxI[,j]=x[exp[,j]+1]\n      pro=pro*count\n    }\n    #獲得主成分的係數向量\n    coef=hcalcov(data1)[[2]]$vectors\n    pro\n    minI\n    maxI\n    #判定細數是否小於0，如果小於0，該系數的區間交換大小位置\n    for (j in 1:p){\n      if (coef[j,com]<0) {\n        a=minI[,j]\n        minI[,j]=maxI[,j]\n        maxI[,j]=a\n      }\n    }\n    \n    #計算線性組合後的區間\n    linmin=minI %*% coef[,com]\n    linmax=maxI %*% coef[,com]\n    m=cbind(linmin[,1],linmax[,1])\n    \n    np=as.data.frame(m)\n    names(np)=c(\"Imin\",\"Imax\")\n    #找出合併後直方圖的range\n    his=np %>% summarise(hmin=min(Imin),hmax=max(Imax))\n    if (B==0) {Bi=max(bij)\n    }else{Bi=B}\n    his=seq(from=his$hmin,to=his$hmax,length.out=Bi+1)\n    \n    \n    #以下先進行對一個區間重疊的計算\n    pp=c()\n    for (b in 1:Bi){\n      testm=cbind(linmin,linmax,his[b],his[b+1])\n      \n      #########完全包含的index  有時候會是空的，沒有任何全包含\n      allcoverindex=which((testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |\n                            (testm[,2]>=testm[,4] & testm[,1]<=testm[,3]))\n      #########篩選出完全包含的\n      allcover=testm[allcoverindex,]\n      if (is(allcover)[2]==\"vector\"){\n        allcover=t(as.matrix(allcover))\n      }\n      #計算完全包含的p值\n      ratio1=min(abs(allcover[,4]-allcover[,3]),abs(allcover[,2]-allcover[,1]))/abs(allcover[,2]-allcover[,1])\n      p1=sum(ratio1*pro[allcoverindex])\n      \n      ################判斷有重疊的index\n      coverindex=which(testm[,2]>testm[,3] & testm[,1]<testm[,4])\n      #######找出有相交，但不是完全包含的index\n      out=coverindex %in% allcoverindex\n      #######找出有相交，但是不是完全包含的\n      takeindex=coverindex[!out]\n      takem=testm[takeindex,]\n      ####算出有take重疊的長度\n      gg=cbind(takem[,2]-takem[,3],takem[,4]-takem[,1])\n      takelen=apply(abs(gg),1,FUN = min)\n      \n      ratio2=takelen/abs(takem[,2]-takem[,1])\n      p2=sum(ratio2*pro[takeindex])\n      pp[b]=p1+p2\n    }\n    ppp[[i]]=pp/sum(pp)\n    hhh[[i]]=his\n  }\n  list(hhh,ppp)\n}\n\n###########################################test\n\n######錯誤\nif (0){\ncreateh=function(data1,com){\n  p=length(data1)\n  n=length(data1[[1]])\n  ppp=vector(\"list\",n)\n  hhh=vector(\"list\",n)\n  for (i in 1:n){\n    bij=c()\n    b=list()\n    for (j in 1:p){\n      bij[j]=length(data1[[j]][[i]]$count)\n      b[[j]]=1:bij[j]\n    }\n    #造所有區間的組合\n    exp=expand.grid(b)\n    #把區間最小值和最大值分別放在不同矩陣(此時只是index)\n    minI=matrix(0,ncol=p,nrow=dim(exp)[1])\n    maxI=matrix(0,ncol=p,nrow=dim(exp)[1])\n    #收集每個區間機率容器\n    pro=rep(1,dim(exp)[1])\n    #放入正確的數值\n    for (j in 1:p){\n      x=data1[[j]][[i]]$breaks\n      count=data1[[j]][[i]]$count\n      minI[,j]=x[exp[,j]]\n      maxI[,j]=x[exp[,j]+1]\n      pro=pro*count\n    }\n    #獲得主成分的係數向量\n    coef=hcalcov(data1)[[2]]$vectors\n    #判定細數是否小於0，如果小於0，該系數的區間交換大小位置\n    for (j in 1:p){\n      if (coef[j,com]<0) {\n        a=minI[,j]\n        minI[,j]=maxI[,j]\n        maxI[,j]=a\n      }\n    }\n    \n    #計算線性組合後的區間\n    linmin=minI %*% coef[,com]\n    linmax=maxI %*% coef[,com]\n    m=cbind(linmin[,1],linmax[,1])\n    \n    np=as.data.frame(m)\n    names(np)=c(\"Imin\",\"Imax\")\n    #找出合併後直方圖的range\n    his=np %>% summarise(hmin=min(Imin),hmax=max(Imax))\n    Bi=max(bij)\n    his=seq(from=his$hmin,to=his$hmax,length.out=Bi+1)\n    \n    \n    #以下先進行對一個區間重疊的計算\n    \n    for (b in 1:Bi){\n      testm=cbind(linmin,linmax,his[b],his[b+1])\n      pp=numeric(Bi)\n      #########完全包含的index  有時候會是空的，沒有任何全包含\n      allcoverindex=which((testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |\n                            (testm[,2]>=testm[,4] & testm[,1]<=testm[,3]))\n      #########篩選出完全包含的\n      allcover=testm[allcoverindex,]\n      if (is(allcover)[2]==\"vector\"){\n        allcover=t(as.matrix(allcover))\n      }\n      #計算完全包含的p值\n      ratio1=min(abs(allcover[,4]-allcover[,3]),abs(allcover[,2]-allcover[,1]))/abs(allcover[,2]-allcover[,1])\n      p1=sum(ratio1*pro[allcoverindex])\n      \n      ################判斷有重疊的index\n      coverindex=which(testm[,2]>testm[,3] & testm[,1]<testm[,4])\n      #######找出有相交，但不是完全包含的index\n      out=coverindex %in% allcoverindex\n      #######找出有相交，但是不是完全包含的\n      takeindex=coverindex[!out]\n      takem=testm[takeindex,]\n      ####算出有take重疊的長度\n      gg=cbind(takem[,2]-takem[,3],takem[,4]-takem[,1])\n      takelen=apply(abs(gg),1,FUN = min)\n      \n      ratio2=takelen/abs(takem[,2]-takem[,1])\n      p2=sum(ratio2*pro[takeindex])\n      pp[b]=p1+p2\n    }\n    ppp[[i]]=pp\n    hhh[[i]]=his\n  }\n  list(hhh,ppp)\n}\n}\n#######去除which 反而比較慢\nif (0){\ncreateh=function(data1,com){\n  p=length(data1)\n  n=length(data1[[1]])\n  ppp=list()\n  hhh=list()\n  for (i in 1:n){\n    bij=c()\n    b=list()\n    #算出某個觀測值得每個值方圖資料有幾個分割\n    for (j in 1:p){\n      bij[j]=length(data1[[j]][[i]]$count)\n      b[[j]]=1:bij[j]\n    }\n    #造所有區間的組合\n    exp=expand.grid(b)\n    #把區間最小值和最大值分別放在不同矩陣(此時只是index)\n    minI=matrix(0,ncol=p,nrow=dim(exp)[1])\n    maxI=matrix(0,ncol=p,nrow=dim(exp)[1])\n    #收集每個區間機率容器\n    pro=rep(1,dim(exp)[1])\n    #放入正確的數值\n    for (j in 1:p){\n      x=data1[[j]][[i]]$breaks\n      count=data1[[j]][[i]]$count\n      minI[,j]=x[exp[,j]]\n      maxI[,j]=x[exp[,j]+1]\n      pro=pro*count\n    }\n    #獲得主成分的係數向量\n    coef=hcalcov(data1)[[2]]$vectors\n    pro\n    minI\n    maxI\n    #判定細數是否小於0，如果小於0，該系數的區間交換大小位置\n    for (j in 1:p){\n      if (coef[j,com]<0) {\n        a=minI[,j]\n        minI[,j]=maxI[,j]\n        maxI[,j]=a\n      }\n    }\n    \n    #計算線性組合後的區間\n    linmin=minI %*% coef[,com]\n    linmax=maxI %*% coef[,com]\n    m=cbind(linmin[,1],linmax[,1])\n    \n    np=as.data.frame(m)\n    names(np)=c(\"Imin\",\"Imax\")\n    #找出合併後直方圖的range\n    his=np %>% summarise(hmin=min(Imin),hmax=max(Imax))\n    Bi=max(bij)\n    his=seq(from=his$hmin,to=his$hmax,length.out=Bi+1)\n    \n    \n    #以下先進行對一個區間重疊的計算\n    pp=c()\n    for (b in 1:Bi){\n      testm=cbind(linmin,linmax,his[b],his[b+1])\n      \n      #########完全包含的index  有時候會是空的，沒有任何全包含\n      allcoverindex=(testm[,2]<=testm[,4] & testm[,1]>=testm[,3]) |\n                            (testm[,2]>=testm[,4] & testm[,1]<=testm[,3])     #########篩選出完全包含的\n      allcover=testm[allcoverindex,]\n      if (is(allcover)[2]==\"vector\"){\n        allcover=t(as.matrix(allcover))\n      }\n      #計算完全包含的p值\n      ratio1=min(abs(allcover[,4]-allcover[,3]),abs(allcover[,2]-allcover[,1]))/abs(allcover[,2]-allcover[,1])\n      p1=sum(ratio1*pro[allcoverindex])\n      \n      ################判斷有重疊的index\n      coverindex=(testm[,2]>testm[,3] & testm[,1]<testm[,4]) |\n                  (testm[,2]<testm[,3] & testm[,1]>testm[,4])\n      #######找出有相交，但不是完全包含的index\n      #######找出有相交，但是不是完全包含的\n      takem=testm[coverindex,]\n      if (is(takem)[2]==\"vector\"){\n        takem=t(as.matrix(takem))\n      }\n      ####算出有take重疊的長度\n      gg=cbind(takem[,2]-takem[,3],takem[,4]-takem[,1])\n      takelen=apply(abs(gg),1,FUN = min)\n      \n      ratio2=takelen/abs(takem[,2]-takem[,1])\n      p2=sum(ratio2*pro[coverindex])\n      pp[b]=p1+p2\n    }\n    ppp[[i]]=pp/sum(pp)\n    hhh[[i]]=his\n  }\n  list(hhh,ppp)\n}\n}\n\n\n\n###################################common desity estmate\ndes_e=function(x,b=10){\n  ymin=min(x[,1])\n  ymax=max(x[,1])\n  xmin=min(x[,2])\n  xmax=max(x[,2])\n  \n  yrange=seq(ymin,ymax,length.out = b+1)\n  xrange=seq(xmin,xmax,length.out = b+1)\n  \n  qq1=matrix(0,nrow=b,ncol=b)\n  for (j in 1:b){\n    for(i in 1:b){\n      qq1[i,j]=sum(x[,1]>=yrange[j] & x[,1]<=yrange[j+1] & x[,2]>=xrange[i] & x[,2]<=xrange[i+1])\n    }\n  }\n  qq1\n}\n\n###################################一般資料轉換成直方圖資料\npoint_to_h=function(x,group){\n  d=dim(x)\n  h=list()\n  a=list()\n  for ( j in 1:d[2]){\n    for(i in 1:length(group)){\n      ff=hist(x[group[[i]],j])\n      ff$counts=ff$counts/sum(ff$counts)\n      a[[i]]=ff\n    }\n    h[[j]]=a\n  }\n  h\n}\n\n#############################################取出質方圖資料的主成分畫圖\nplotcom=function(x){\n  n=length(x[[1]])\n  p=length(x)\n  for (j in 1:2){\n    if(j==1) {\n      par(mfcol=c(n,2),mai=c(0,0,0,0))\n      kk=hist(iris[,1],plot=F)\n    }\n    dda=createh(data1=x,com=j)\n    tt=laply(dda[[1]],max)\n    bma=max(tt)\n    tt=laply(dda[[1]],min)\n    bmi=min(tt)\n    tt=laply(dda[[2]],max)\n    pma=max(tt)\n    tt=laply(dda[[2]],min)\n    pmi=min(tt)\n    for (i in 1:n){\n      kk$breaks=dda[[1]][[i]]\n      kk$counts=dda[[2]][[i]]\n      plot(kk,xlim=c(bmi-2,bma+1),ylim=c(0,pma),main=\"\",col=\"blue\",ylab = \"\")\n    }\n  }\n}\n\n\n#####################\ncolor.Palette <- function(low = \"black\",\n                          high = c(\"green\", \"red\"),\n                          mid=\"black\",\n                          k =50)\n{\n  low <- col2rgb(low)/255\n  high <- col2rgb(high)/255\n  if(is.null(mid)){\n    r <- seq(low[1], high[1], len = k)\n    g <- seq(low[2], high[2], len = k)\n    b <- seq(low[3], high[3], len = k)\n  }\n  if(!is.null(mid)){\n    k2 <- round(k/2)\n    mid <- col2rgb(mid)/255\n    r <- c(seq(low[1], mid[1], len = k2),\n           seq(mid[1], high[1], len = k2))\n    g <- c(seq(low[2], mid[2], len = k2),\n           seq(mid[2], high[2], len = k2))\n    b <- c(seq(low[3], mid[3], len = k2),\n           seq(mid[3], high[3], len = k2))\n  }\n  rgb(r, g, b)\n}\n\n\n###################################################plot joint histo\n#yr=seq(-4,4,by=.1)\n#xr=seq(4,12,by=.1)\nplotjointh=function(x,b,...){\n  dda1=createh(data1=x,com=1,...)\n  dda2=createh(data1=x,com=2,...)\n  xmax=dda1[[1]] %>% unlist %>% max\n  xmin=dda1[[1]] %>% unlist %>% min\n  ymax=dda2[[1]] %>% unlist %>% max\n  ymin=dda2[[1]] %>% unlist %>% min\n  xr=seq(xmin,xmax,length.out = b)\n  yr=seq(ymin,ymax,length.out = b)\n  lastjoint=matrix(0,ncol=(length(yr)-1),nrow=(length(xr)-1))\n  part=list()\n  for (s in 1:length(dda1[[1]])){\n    b1=list(breaks=dda1[[1]][[s]],counts=dda1[[2]][[s]])\n    b2=list(breaks=dda2[[1]][[s]],counts=dda2[[2]][[s]])\n    joint=matrix(0,ncol=(length(yr)-1),nrow=(length(xr)-1))\n    for (j in 1:(length(yr)-1)){\n      for (i in 1:(length(xr)-1)){\n        gg=0\n        allrange=(xr[i+1]-xr[i])*(yr[j+1]-yr[j])\n        for(p in 1:length(b1$counts)){\n          for(k in 1:length(b2$counts)){\n            aa=min(xr[i+1]-b1$breaks[p],b1$breaks[p+1]-xr[i])\n            if (aa<0) aa=0\n            bb=min(yr[j+1]-b2$breaks[k],b2$breaks[k+1]-yr[j])\n            if (bb<0) bb=0\n            if (b1$breaks[p]>=xr[i] & b1$breaks[p+1]<=xr[i+1]) aa=b1$breaks[p+1]-b1$breaks[p]\n            if (b1$breaks[p]<=xr[i] & b1$breaks[p+1]>=xr[i+1]) aa=xr[i+1]-xr[i]\n            if (b2$breaks[k]>=yr[j] & b2$breaks[k+1]<=yr[j+1]) bb=b2$breaks[k+1]-b2$breaks[k]\n            if (b2$breaks[k]<=yr[j] & b2$breaks[k+1]>=yr[j+1]) bb=yr[j+1]-yr[j]\n            coverratio=(aa*bb)/allrange\n            gg=gg+coverratio*b1$counts[p]*b2$counts[k]\n          }\n        }\n        joint[i,j]=gg\n      }\n    }\n    #part[[s]]=joint\n    lastjoint=lastjoint+joint\n  }\n  image(lastjoint)\n}",
    "created" : 1452837854095.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "5|21|19|0|\n21|25|40|0|\n42|20|58|0|\n62|32|154|0|\n160|28|247|0|\n251|28|343|0|\n440|29|480|0|\n",
    "hash" : "1755839873",
    "id" : "D12BB5FF",
    "lastKnownWriteTime" : 1454152033,
    "path" : "C:/Users/TSR/Desktop/2015-9-1-R/paper code/paperfuction.R",
    "project_path" : "paperfuction.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}