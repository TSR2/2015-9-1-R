{
    "contents" : "################################################################################\n#    R code for Histogram SIR                                                  #\n#                                                                              #\n#    Han-Ming Wu (hmwu@mail.tku.edu.tw)                                        #\n#    Department of Mathematics, Tamkang University                             #\n#                                                                              #\n#    For update or correctness,                                                #\n#    please visit at http://www.hmwu.idv.tw                                    #\n#                                                                              #\n#    Version 2014-04-27, Initial Release                                       #\n################################################################################\n\n\n\n\n##\n## [N x p]: classical data\n## to histogram data according to each group\n## xI = xI[[i]][[j]], i=1,...,n, j=1,...,p   #breaks: list of lists\n## xI[][1]: 1st observation, xI[1][]\n## xI[][2]: 2nd observation, xI[2][]\n\n\n## xP = xP[[i]][[j]]                         #probabilities\n##\n\n## Bij=[n p]\nToHistogramData <- function(xdata, group.id, no.bar, is.plot=F){\n    \n    #     xdata <- iris[,1:4]\n    #     group.id <- as.integer(iris[,5]) ## 1,2,...\n    \n    no.group <- length(unique(group.id))\n    n <- no.group\n    p <- ncol(xdata)\n    N <- nrow(xdata)\n    \n    xI <- vector(\"list\", n)\n    xP <- vector(\"list\", n)\n    Bij <- matrix(0, nrow=n, ncol=p)  ## number of bins\n    \n    if(is.plot==TRUE){\n        par(mfrow=c(n,p), mar=c(3,2,2,1))    \n    }\n    \n    \n    for(i in 1:n){\n        at <- which(group.id==i)\n        for(j in 1:p){             \n            subset <- xdata[at, j]\n            if(is.plot==T){\n                if(no.bar==0){\n                    xh <- hist(subset, plot = TRUE, main=\"\", freq = F)                                  \n                }else{\n                    xh <- hist(subset, breaks=seq(min(subset), max(subset), \n                                                  length=no.bar+1), plot = TRUE, main=\"\", freq = F)              \n                }\n                \n            }else{\n                if(no.bar==0){\n                    xh <- hist(subset, plot = FALSE)                                            \n                }else{\n                    xh <- hist(subset, breaks=seq(min(subset), max(subset), \n                                                  length=no.bar+1), plot = FALSE)\n                }\n            }                                        \n            xI[[i]][[j]] <- xh$breaks\n            \n            xP[[i]][[j]] <- xh$counts/sum(xh$counts)\n            \n            Bij[i, j] <- length(xh$counts)\n        }\n        \n    }\n    \n    xO <- NULL\n    \n    histMatrix <- list(xI=xI, xP=xP, xO=xO, Bij=Bij)\n    histMatrix\n    \n}\n\n#################################################\n#                                               #\n#                                               #\n#################################################\n## stratified sampling \nToHistogramData.random <- function(xdata, group.id, no.bar, is.plot=F, \n                                   no.hist.each.group=5,\n                                   no.sample.each.group=30){\n    \n    #     xdata <- iris[,1:4]\n    #     group.id <- as.integer(iris[,5]) ## 1,2,...\n    \n    ng <- no.hist.each.group \n    \n    no.group <- length(unique(group.id))\n    n <- no.group*ng\n    p <- ncol(xdata)\n    N <- nrow(xdata)\n    \n    xI <- vector(\"list\", n)\n    xP <- vector(\"list\", n)\n    Bij <- matrix(0, nrow=n, ncol=p)  ## number of bins\n    \n    if(is.plot==TRUE){\n        par(mfrow=c(n,p), mar=c(3,2,2,1))    \n    }\n    \n    group.id.list <- vector(\"list\", no.group)\n    for(i in 1:no.group){\n        group.id.list[[i]] <- which(group.id==i)    \n    }\n    \n    \n    \n    for(i in 1:no.group){\n        for(r in 1:ng){\n                        \n            at <- sample(group.id.list[[i]], no.sample.each.group)\n            \n            for(j in 1:p){             \n                subset <- xdata[at, j]\n                if(is.plot==T){\n                    if(no.bar==0){\n                        xh <- hist(subset, plot = TRUE, main=\"\", freq = F)                                  \n                    }else{\n                        xh <- hist(subset, breaks=seq(min(subset), max(subset), \n                                                      length=no.bar+1), plot = TRUE, main=\"\", freq = F)              \n                    }\n                    \n                }else{\n                    if(no.bar==0){\n                        xh <- hist(subset, plot = FALSE)                                                             \n                    }else{\n                        xh <- hist(subset, breaks=seq(min(subset), max(subset), \n                                                      length=no.bar+1), plot = FALSE)                                         \n                    }\n                }                                        \n                xI[[(i-1)*ng+r]][[j]] <- xh$breaks                \n                xP[[(i-1)*ng+r]][[j]] <- xh$counts/sum(xh$counts)                \n                Bij[(i-1)*ng+r, j] <- length(xh$counts)\n            }\n            \n        }\n    }\n    \n    xO <- rep(c(1:no.group), each=ng)\n    \n    histMatrix <- list(xI=xI, xP=xP, xO=xO, Bij=Bij)\n    histMatrix\n    \n}\n\n#################################################\n#                                               #\n#                                               #\n#################################################\n# fdata: factor data\n# construct histogram from categories (factors)\n\nToHistogramData.factor <- function(xdata, group.id, fdata, no.bar=0, is.plot=F){\n    \n    #xdata <- x.orig\n    #fdata <- f.orig\n    #group.id <- y.orig\n    \n    f.ncol <- ncol(fdata)\n    f.nrow <- nrow(fdata)\n        \n    #cat(\"f.ncol:\", f.ncol)\n    \n    ft <- table(fdata)\n    levels.length <- dim(ft)\n    f.levels <- lapply(fdata, levels)\n    \n    #> f.levels\n    #$occupation\n    #[1] \"?\"                 \"Adm-clerical\"      \"Armed-Forces\"     \n    #[4] \"Craft-repair\"      \"Exec-managerial\"   \"Farming-fishing\"  \n    #[7] \"Handlers-cleaners\" \"Machine-op-inspct\" \"Other-service\"    \n    #[10] \"Priv-house-serv\"   \"Prof-specialty\"    \"Protective-serv\"  \n    #[13] \"Sales\"             \"Tech-support\"      \"Transport-moving\" \n    #    \n    #$race\n    #[1] \"Amer-Indian-Eskimo\" \"Asian-Pac-Islander\" \"Black\"             \n    #[4] \"Other\"              \"White\"             \n    # \n    #$gender\n    #[1] \"Female\" \"Male\"          \n    \n    \n    no.group <- length(unique(group.id))\n    \n    p <- ncol(xdata)\n    N <- nrow(xdata)\n    \n    \n    ## wrong\n    #if(is.plot==TRUE){\n    #    par(mfrow=c(n,p), mar=c(3,2,2,1))    \n    #}\n         \n    list1 <- vector(\"list\", f.ncol)    \n    \n    for(i in 1:f.ncol){\n        list1[[i]] <- 1:levels.length[i]\n    }\n    #print(list1)\n    \n    factor.at <- index.seq(list1)\n    \n    #[146,]   15    3    2\n    #[147,]   15    4    1\n    #[148,]   15    4    2\n    #[149,]   15    5    1\n    #[150,]   15    5    2\n    \n    factor.at.nrow <- nrow(factor.at)\n    \n    n <- factor.at.nrow*no.group\n    xI <- vector(\"list\", n)\n    xP <- vector(\"list\", n)\n    Bij <- matrix(0, nrow=n, ncol=p)  ## number of bins\n    xO <- numeric(n)\n        \n        \n    count <- 1\n    # g <- 1\n    for(g in 1:no.group){\n                        \n        # k <- 131\n        for(k in 1:factor.at.nrow){\n            \n            at.subset <- which(group.id==g)\n            \n            for(i in 1:f.ncol){\n                at.facor.id <- which(fdata[, i] ==  f.levels[[i]][factor.at[k,i]]) \n                at.subset <- intersect(at.subset, at.facor.id)                                    \n            }\n            \n            #cat(\"\\n\", length(at.subset), \"\\n\")\n            if(length(at.subset)>10){\n                \n                # j <- 2\n                for(j in 1:p){             \n                    \n                    subset <- xdata[at.subset, j]    \n                    \n                    if(is.plot==T){\n                        if(no.bar==0){\n                            xh <- hist(subset, plot = TRUE, main=\"\", freq = F)                                  \n                        }else{\n                            xh <- hist(subset, breaks=seq(min(subset), max(subset), \n                                                          length=no.bar+1), plot = TRUE, main=\"\", freq = F)              \n                        }\n                        \n                    }else{\n                        if(no.bar==0){\n                            xh <- hist(subset, plot = FALSE)                                            \n                        }else{\n                            xh <- hist(subset, breaks=seq(min(subset), max(subset), \n                                                          length=no.bar+1), plot = FALSE)\n                        }\n                    }                                        \n                    \n                    #cat(\"g:\", g, \" k:\", k, \" j:\", j, \"\\n\")\n                    xI[[count]][[j]] <- xh$breaks\n                    \n                    xP[[count]][[j]] <- xh$counts/sum(xh$counts)\n                    \n                    Bij[count, j] <- length(xh$counts)\n                    \n                    \n                }\n                xO[count] <- g\n                count <- count + 1\n            }\n        }                \n    }\n    \n    n <- count-1    \n    histMatrix <- list(xI=xI[1:n], xP=xP[1:n], xO=xO[1:n], Bij=Bij[1:n, ])\n    histMatrix\n    \n}\n\n#################################################\n#                                               #\n#                                               #\n#################################################\nToHistogramObject <- function(xIij, xPij){\n    \n    h.obj <- list(breaks=xIij, density=xPij, counts=xPij*100)    \n    attr(h.obj, \"class\") <- \"histogram\"\n    h.obj\n    \n}\n\n\n#################################################\n#                                               #\n#                                               #\n#################################################\n#>     xI.jth\n#[[1]]\n#[1] 12.0 12.9 13.2 13.5 13.8 14.1 14.4 14.7 15.0\n#\n#[[2]]\n#[1] 10.5 11.0 11.3 11.6 11.9 12.2 12.5 12.8 14.0\n#\n#[[3]]\n#[1] 10.5 11.0 11.5 11.8 12.1 12.4 12.7 13.0 14.0\n\n\n# get.jth(xI, 1)\n# get.jth(xP, 2)\n\n# cholesterol\n# > range(get.jth(xI, 3))\n#[1]  80 270\n#> \n\n# hemoglobin\n#> range(get.jth(xI, 1))\n#[1] 10.2 15.0\n\n##\n## get all observations of the jth histogram variable\n##\nget.jth <- function(xIP, j){\n    \n    n <- length(xIP)\n    xIP.jth <- vector(\"list\", n)\n    \n    for(k in 1:n){            \n        xIP.jth[k] <- xIP[[k]][j]           \n    }\n    xIP.jth\n    \n}\n\n\n\n#################################################\n#                                               #\n#                                               #\n#################################################\n#\n# the same x-scale, y-scale, so that each histogram\n# of the same variable can be compared. \n\nplot.histMatrix <- function(histMatrix){\n    \n    \n    xI <- histMatrix$xI\n    xP <- histMatrix$xP \n    xO <- histMatrix$xO \n    Bij <- histMatrix$Bij\n    \n    \n    color <- c(\"lightpink\", \"lightgreen\", \"lightblue\",\n               \"lightgoldenrod\",\n               \"gray\", \"thistle\",\"slateblue1\", \"darkseagreen1\",\n               \"tomato\",\"lemonchiffon3\",\"royalblue1\",\n               \"yellowgreen\", \"slategrey\"\n               )\n    \n    # is.theSameLimit=T\n    # so that histograms can be compared\n    \n    n <- nrow(Bij)\n    p <- ncol(Bij)\n    \n    if(n>10){\n        par(mfrow=c(n, p), mar=c(0,0,0,0))    \n    }else{\n        par(mfrow=c(n, p), mar=c(3,2,2,1))    \n    }\n    \n    jmin <- numeric(p)\n    jmax <- numeric(p)\n    ymax <- numeric(p)\n    for(j in 1:p){                   \n        jmax[j] <- max(xI[[1]][[j]])\n        jmin[j] <- min(xI[[1]][[j]])\n        ymax[j] <- max(xP[[1]][[j]])\n        for(i in 2:n){        \n            jmax[j] <- max(jmax[j], xI[[i]][[j]])\n            jmin[j] <- min(jmin[j], xI[[i]][[j]])\n            ymax[j] <- max(ymax[j], xP[[i]][[j]])\n        }\n    }\n    \n    \n    for(i in 1:n){        \n        for(j in 1:p){                        \n            h <- ToHistogramObject(xI[[i]][[j]], xP[[i]][[j]]) \n            \n            if(i==n){\n                plot(h, main=\"\", axes=T, col=color[j], \n                     xlim=c(jmin[j], jmax[j]),\n                     ylim=c(0, ymax[j]), freq=F\n                )\n                \n            }else{\n                plot(h, main=\"\", axes=F, col=color[j], \n                     xlim=c(jmin[j], jmax[j]),\n                     ylim=c(0, ymax[j]), freq=F, yaxt = 'n'\n                )                \n            }\n            \n            if(i==n){\n                axis(1, labels=T)    \n            }else{\n                axis(1, labels=F)\n            }\n            \n        }\n    }        \n    \n}\n\n\n\n#################################################\n#                                               #\n#                                               #\n#################################################\n# table6 <- t6()\n# histMatrix.mean(table6)\n# > histMatrix.mean(table6)\n# [1] 143.9129\n\n\nhistMatrix.mean <- function(histMatrix){\n    \n    \n    xI <- histMatrix$xI\n    xP <- histMatrix$xP \n    xO <- histMatrix$xO \n    Bij <- histMatrix$Bij\n    \n    n <- nrow(Bij)\n    p <- ncol(Bij)\n    \n    mu <- numeric(p)\n    for(j in 1: p){\n        for(i in 1:n){                                            \n            px <- sum(xP[[i]][[j]]*(xI[[i]][[j]][1:Bij[i, j]]+\n                                        xI[[i]][[j]][2:(Bij[i, j]+1)]))\n            mu[j] <- mu[j] + px\n        }         \n        mu[j] <- mu[j]/(2*n)\n    }\n    mu\n    \n    \n}\n\n#################################################\n#                                               #\n#                                               #\n#################################################\n# histMatrix.mean.s2(table6)\n## EJD methods\n#$mu\n#[1] 143.9129\n#\n#$s2\n#[1] 447.5115\nhistMatrix.mean.s2 <- function(histMatrix){\n    \n    \n    xI <- histMatrix$xI\n    xP <- histMatrix$xP \n    xO <- histMatrix$xO \n    Bij <- histMatrix$Bij\n    \n    n <- nrow(Bij)\n    p <- ncol(Bij)\n    \n    mu <- numeric(p)\n    s2 <- numeric(p)\n    for(j in 1: p){\n        for(i in 1:n){                            \n            ## mean            \n            px <- sum(xP[[i]][[j]]*(xI[[i]][[j]][1:Bij[i, j]]+\n                                        xI[[i]][[j]][2:(Bij[i, j]+1)]))\n            mu[j] <- mu[j] + px\n            \n            ## var\n            px <- sum(xP[[i]][[j]]*(xI[[i]][[j]][1:Bij[i, j]]^2+\n                                     xI[[i]][[j]][2:(Bij[i, j]+1)]^2+\n                                     xI[[i]][[j]][1:Bij[i, j]]*\n                                        xI[[i]][[j]][2:(Bij[i, j]+1)]))            \n            s2[j] <- s2[j] + px\n        }         \n        mu[j] <- mu[j]/(2*n)\n        s2[j] <- s2[j]/(3*n)-mu[j]^2\n    }\n    \n    list(mu=mu, s2=s2)\n            \n}\n\n\n#################################################\n#                                               #\n#                                               #\n#################################################\n# histMatrix.cov(table6)\n\n# ch04.data <- ch04()\n# histMatrix.cov(ch04.data)\n# sqrt(diag(histMatrix.cov(ch04.data)$cov.EJD))\n# [1]  0.7393177  2.7434493 31.6597432\nhistMatrix.cov <- function(histMatrix){\n    \n    \n    xI <- histMatrix$xI\n    xP <- histMatrix$xP \n    xO <- histMatrix$xO \n    Bij <- histMatrix$Bij\n    \n    n <- nrow(Bij)\n    p <- ncol(Bij)\n    \n    mu <- numeric(p)\n    s2 <- numeric(p)\n    cov.EJD <- matrix(0, ncol=p, nrow=p)\n    cov.GQ <- matrix(0, ncol=p, nrow=p)\n    \n    xbaru <- matrix(0, nrow=n, ncol=p)\n    \n    ## var\n    for(j in 1: p){\n                        \n        for(i in 1:n){                \n            ## mean in each histogram\n                        \n            \n            ## mean            \n            px <- sum(xP[[i]][[j]]*(xI[[i]][[j]][1:Bij[i, j]]+\n                                        xI[[i]][[j]][2:(Bij[i, j]+1)]))\n            \n            xbaru[i,j] <- px/2\n            \n            mu[j] <- mu[j] + px\n            \n            ## var\n            px <- sum(xP[[i]][[j]]*(xI[[i]][[j]][1:Bij[i, j]]^2+\n                                        xI[[i]][[j]][2:(Bij[i, j]+1)]^2+\n                                        xI[[i]][[j]][1:Bij[i, j]]*\n                                        xI[[i]][[j]][2:(Bij[i, j]+1)]))            \n            s2[j] <- s2[j] + px\n        }         \n        mu[j] <- mu[j]/(2*n)\n        s2[j] <- s2[j]/(3*n)-mu[j]^2\n        \n    }    \n    \n    \n    ## cov\n    for(j in 1:(p-1)){\n        for(k in (j+1):p){\n                        \n            pxj <- 0\n            pxk <- 0\n            py <- 0\n            \n            for(i in 1:n){                                                \n                px1 <- sum(xP[[i]][[j]]*(xI[[i]][[j]][1:Bij[i, j]]+\n                                             xI[[i]][[j]][2:(Bij[i, j]+1)]))\n                px2 <- sum(xP[[i]][[k]]*(xI[[i]][[k]][1:Bij[i, k]]+\n                                             xI[[i]][[k]][2:(Bij[i, k]+1)]))\n                \n                pxj <- pxj + px1\n                pxk <- pxk + px2\n                \n                for(b in 1:Bij[i, j]){\n                    \n                    py1 <- sum((xP[[i]][[j]][b]*xP[[i]][[k]])*\n                                   (xI[[i]][[j]][b]+xI[[i]][[j]][b+1])*                \n                                   (xI[[i]][[k]][1:Bij[i, k]]+\n                                        xI[[i]][[k]][2:(Bij[i, k]+1)]))            \n                    py <- py + py1\n                }    \n                \n            }        \n            cov.EJD[j, k] <- py/(4*n)- (pxj * pxk)/(4*n^2)\n            cov.EJD[k, j] <- cov.EJD[j, k]                                    \n        }\n        cov.EJD[j, j] <- s2[j]                        \n    }   \n    cov.EJD[p, p] <- s2[p]                        \n        \n    \n    ################################\n    # Sjj'=QQ                      #\n    ################################\n    # (12) sign matrix of the correlations\n    #Gj <- matrix(-1, n, p)\n    #Qj = matrix(0, nrow=n, ncol=p)\n    #\n    #for(j in 1:p){\n    #   for(i in 1:n){ \n    #        if (xbaru[i,j] > xbar[j]){\n    #            Gj[i,j] = 1\n    #        }                            \n    #    }\n    #}\n    #\n    #\n    #Qj[i,j] = (xI[[i]][[j]] - mu[j])^2 + \n    #    (xI[[i]][[j]] - mu[j])*(xI[[i]][[j]] - mu[j]) + \n    #    (xI[[i]][[j]] - mu[j])^2\n    #\n    #\n    #################################\n    ## Sjj'=GQ                      #\n    #################################\n    #if(i==j){\n    #    a <- sum(idata.x[, i,2]^2 + idata.x[, i,1]*idata.x[, i,2]+idata.x[,i,1]^2)\n    #    b <- (sum(idata.x[, i,1] + idata.x[, i,2]))^2                \n    #    Cov.GQ[i, j] <- a/(3*n)-b/(4*n^2)\n    #}else{\n    #    Cov.GQ[i,j] <- sum((Gu[,i]*Gu[,j]*sqrt(Qu[,i]*Qu[,j])))/(3*n)\n    #    Cov.GQ[j,i] <- Cov.GQ[i,j]                \n    #}\n    \n\n    \n    list(cov.EJD=cov.EJD, cov.GQ=cov.GQ)\n    \n#    list(covxy=covxy)\n    \n}\n    \n\n\n###########################################################\n#                                                         #\n#                                                         #\n###########################################################\n#\n# for one histogram-variable (jth variable), there are n histograms,\n# we summary these histograms by a histogram\n\n\n# histMatrix <- t6()\n# hist.of.histograms(histMatrix, 1)\n    \nhist.of.histograms <- function(histMatrix, jth, R=0){\n    \n    # R: number of intervals\n    # jth <- 1   # jth variable\n        \n    \n            \n    xI <- histMatrix$xI\n    xP <- histMatrix$xP \n    xO <- histMatrix$xO \n    Bij <- histMatrix$Bij\n    \n    n <- nrow(Bij)\n    p <- ncol(Bij)\n        \n    \n    xP.jth <- get.jth(xP, jth)\n    xI.jth <- get.jth(xI, jth)\n    I <- range(unlist(lapply(xI.jth, range)))    \n    \n    ## number of intervals\n    if(R==0){\n        R <- max(unlist(lapply(xP.jth, length)))    \n    }    \n    \n    Ig <- seq(min(I),max(I), length=R+1)\n    \n    ## test code\n    # R <- 10\n    # Ig <- c(60, 75, 90, 105, 120, 135, 150, 165, 180, 195, 210)\n            \n    # r <- 5\n    # b <- 1\n    # i <- 1\n    \n    # observed frequency\n    piZ <- numeric(R)\n    for(r in 1: R){\n        \n        ## the interval of the resulting histogram\n        ai <- Ig[r] \n        bi <- Ig[r+1]  \n        \n        \n        for(i in 1:n){    \n            \n            for(b in 1: Bij[i, jth]){                            \n                ci <- xI[[i]][[jth]][b]  \n                di <- xI[[i]][[jth]][b+1] \n                zIg <- 0\n                if( !((bi <= ci) | (di <= ai))){                    \n                    #cat(\"b: \", b, \"\\n\")\n                    if((ai <= ci) & (ci <= bi) & (bi <= di)){  ## a c b d\n                        zIg <- abs(bi-ci)\n                    }\n                    if((ci <= ai) & (ai <= di) & (di <= bi)){ ## c a d b\n                        zIg <- abs(di-ai)\n                    }\n                    if((ai <= ci) & (ci <= di) & (di <= bi)){ ## a c d b\n                        zIg <- abs(di-ci)\n                    }\n                    if((ci <= ai) & (ai <= bi) & (bi <= di)){ ## c a b d\n                        zIg <- abs(bi-ai)\n                    }\n                    #cat(zIg,\"\\t\", abs(di-ci), \"\\t\", xP[[i]][[jth]][b], \"\\n\")            \n                    piZ[r] <- piZ[r] + zIg*xP[[i]][[jth]][b]/abs(di-ci) \n                }                            \n            }\n            \n        }\n           \n    }\n    \n    ## relative frequency\n    piZ <- piZ/n\n    \n    color <- c(\"lightpink\", \"lightgreen\", \"lightblue\",\n               \"lightgoldenrod\",\n               \"gray\", \"thistle\",\"slateblue1\", \"darkseagreen1\",\n               \"tomato\",\"lemonchiffon3\",\"royalblue1\",\n               \"yellowgreen\", \"slategrey\"\n    )\n    \n    h.obj <- ToHistogramObject(Ig, piZ)    \n    plot(h.obj, main=\"Histogram of histograms\", \n         freq=F, ylab=\"Relative Frequency\", col=color[jth])\n    \n    h.obj        \n}\n\n\n\n\n\n###########################################################\n#                                                         #\n#                                                         #\n###########################################################\n#\n# hist1: histogram, may come from a histogram of histograms\n# hist2\n# \n# hist1 is a histogram object\n# list(breaks=xIij, density=xPij, counts=xPij*100)    \n\n# histMatrix <- ch04()    \n# jh <- joint.histogram(histMatrix, 4, 1) \n\n\n# automatic setting, if R1=0, R2=0, y.id=0\n# \n# joint.histogram(proj.histMatrix.sir, 2, 1)  \n# histMatrix <- proj.histMatrix.sir\n# jth <- 2 \n# kth <- 1  \n# R1=0; R2=0; DR=\"DR\"\n\njoint.histogram <- function(histMatrix, jth, kth, R1=0, R2=0, DR=\"DR\"){\n  \n    ## DR the name in the title\n            \n    xI <- histMatrix$xI\n    xP <- histMatrix$xP \n    xO <- histMatrix$xO #class labels\n    Bij <- histMatrix$Bij\n    \n    n <- nrow(Bij)\n    p <- ncol(Bij)\n        \n    xP.jth <- get.jth(xP, jth)\n    xI.jth <- get.jth(xI, jth)\n    xP.kth <- get.jth(xP, kth)\n    xI.kth <- get.jth(xI, kth)\n    \n    I1 <- range(unlist(lapply(xI.jth, range)))    \n    I2 <- range(unlist(lapply(xI.kth, range)))    \n    \n    ## number of intervals\n    if(R1==0){\n        R1 <- max(unlist(lapply(xP.jth, length)))\n    }    \n    if(R2==0){\n        R2 <- max(unlist(lapply(xP.kth, length)))\n    }        \n    Ig1 <- round(seq(min(I1),max(I1), length=R1+1),1)\n    Ig2 <- round(seq(min(I2),max(I2), length=R2+1),1)\n    \n    ## test code\n    # R1 <- 6\n    # Ig1 <- c(75, 110, 145, 180, 215, 250, 285)\n    # R2 <- 5\n    # Ig2 <- c(10, 11, 12, 13, 14, 15)\n    \n        \n    piZ <- matrix(0, nrow=R1, ncol=R2)\n    no.group <- length(unique(xO))\n    piZ.class <- array(0, dim=c(R1, R2, no.group))\n    \n    \n    # r1 <- 1\n    # r2 <- 1\n    for(r1 in 1: R1){\n        \n        ai1 <- Ig1[r1] \n        bi1 <- Ig1[r1+1]  \n        \n        for(r2 in 1: R2){\n                    \n            ai2 <- Ig2[r2] \n            bi2 <- Ig2[r2+1]  \n            \n            # i <- 2\n            for(i in 1:n){    \n                            \n                piZ1 <- 0\n                piZ2 <- 0\n                \n                for(b1 in 1: Bij[i, jth]){                            \n                    \n                    ci1 <- xI[[i]][[jth]][b1]  \n                    di1 <- xI[[i]][[jth]][b1+1] \n                    \n                    zIg1 <- 0\n                    if(!((bi1 <= ci1) | (di1 <= ai1))){                    \n                        \n                        if((ai1 <= ci1) & (ci1 <= bi1) & (bi1 <= di1)){                               \n                            zIg1 <- abs(bi1-ci1)\n                            \n                        }\n                        if((ci1 <= ai1) & (ai1 <= di1) & (di1 <= bi1)){                            \n                            zIg1 <- abs(di1-ai1)\n                            \n                        }\n                        if((ai1 <= ci1) & (ci1 <= di1) & (di1 <= bi1)){                             \n                            zIg1 <- abs(di1-ci1)\n                            \n                        }\n                        if((ci1 <= ai1) & (ai1 <= bi1) & (bi1 <= di1)){                             \n                            zIg1 <- abs(bi1-ai1)\n                            \n                        }\n                        \n                        piZ1 <- piZ1 + zIg1*xP[[i]][[jth]][b1]/abs(di1-ci1)                                                 \n                    }\n                }\n                for(b2 in 1: Bij[i, kth]){                            \n                    ci2 <- xI[[i]][[kth]][b2]  \n                    di2 <- xI[[i]][[kth]][b2+1] \n                    \n                    zIg2 <- 0                        \n                    if(!((bi2 <= ci2) | (di2 <= ai2))){                                                \n                        \n                        if((ai2 <= ci2) & (ci2 <= bi2) & (bi2 <= di2)){                                 \n                            zIg2 <- abs(bi2-ci2)\n                        }\n                        \n                        if((ci2 <= ai2) & (ai2 <= di2) & (di2 <= bi2)){                            \n                            zIg2 <- abs(di2-ai2)\n                        }\n                        \n                        if((ai2 <= ci2) & (ci2 <= di2) & (di2 <= bi2)){\n                            zIg2 <- abs(di2-ci2)\n                        }\n                        \n                        if((ci2 <= ai2) & (ai2 <= bi2) & (bi2 <= di2)){                               \n                            zIg2 <- abs(bi2-ai2)\n                        }\n                        \n                        #cat(zIg2,\"\\t\", abs(di2-ci2), \"\\t\", xP[[i]][[kth]][b2], \"\\n\")                                   \n                        piZ2 <- piZ2 + zIg2*xP[[i]][[kth]][b2]/abs(di2-ci2)                              \n                    }\n                    \n                    \n                }\n                #piZ1 * piZ2\n                \n                piZ[r1, r2] <- piZ[r1, r2] + piZ1 * piZ2\n                piZ.class[r1, r2, xO[i]] <- piZ.class[r1, r2, xO[i]] + piZ1 * piZ2\n                \n            }\n                                \n        }\n        \n        \n    }\n    \n    fZ <- piZ ##frequency\n    pZ <- piZ/n  ##probability\n    piZ.class <- piZ.class/n\n    \n    Rowname <- paste(\"[\", Ig1[1:R1], \",\", Ig1[2:(R1+1)], \")\", sep=\"\")\n    Colname <- paste(\"[\", Ig2[1:R2], \",\", Ig2[2:(R2+1)], \")\", sep=\"\")\n    \n    rownames(fZ) <- Rowname\n    colnames(fZ) <- Colname    \n    \n    rownames(pZ) <- Rowname\n    colnames(pZ) <- Colname    \n    \n    rownames(piZ.class) <- Rowname\n    colnames(piZ.class) <- Colname   \n    \n    #colSums(piZ)\n    #rowSums(piZ)\n        \n    joint.hist <- list(breaks.x=Ig1, breaks.y=Ig2, pZ=pZ, fZ=fZ)\n    \n    ## histogram 3D\n    rgl.open()\n    rgl.bg(col=\"#cccccc\")\n    hist3d(joint.hist, alpha=1)\n            \n    ## image 2D    \n    ## for all data\n    myImagePlot(pZ, title=paste(\"Joint Histogram of Histograms: (\", DR, \n                                kth, \", \", DR, jth,\")\", sep=\"\"))\n    \n    ## image 2D    \n    ## for each cluster: xO is group id\n    for(g in 1:no.group){\n        myImagePlot(piZ.class[,,g], title=paste(\"Joint Histogram of Histograms: (\", DR, \n                                    kth, \", \", DR, jth,\"), C\",g, sep=\"\"))\n        \n    }\n    \n    \n    \n    \n    joint.hist\n}\n\n\n\n\n\n###########################################################\n## color:rainbow130                                       #\n###########################################################\n\nrainbow130 <- function(n){\n    \n    rainbow130.rgb <- rgb(read.table(\"color-rainbow130.txt\" , header=FALSE))\n    \n    \n    if(n>130){\n        a <- n%/%130\n        b <- n-130*a\n        id <- c(rep(c(1:b), each=(a+1)), rep(c((b+1):130), each=a))    \n    }else{        \n        id <- as.integer(seq(1, 130, length=n))    \n    }        \n    color <- rainbow130.rgb[id]\n    \n    color\n}\n\n\n###########################################################\n#                                                         #\n#                                                         #\n###########################################################\n## rgl\n# joint.hist <- joint.histogram(histMatrix, 3, 1)\n\nhist3d <- function(joint.hist, alpha=1, col=\"#ff0000\", scale=10){\n    \n    \n    save <- par3d(skipRedraw=TRUE)\n    on.exit(par3d(save))\n        \n    xI <- joint.hist$breaks.x\n    xI <- (xI-min(xI))/(max(xI)-min(xI))\n    yI <- joint.hist$breaks.y\n    yI <- (yI-min(yI))/(max(yI)-min(yI))\n    \n    z <- joint.hist$fZ\n        \n    nIx <- length(xI)-1\n    nIy <- length(yI)-1\n            \n    rainbow.col <- rainbow130(130)[130:1]        \n    col.id <- as.integer((z-min(z))/(max(z)-min(z))*129+1)    \n    my.color <- rainbow.col[col.id]\n        \n    #plot(1:30, c(z), col=my.color, pch=16)\n    \n    color.mat <- matrix(my.color, nrow=nrow(z), ncol=ncol(z), byrow=F)\n    \n    for (i in 1:nIx) {        \n        for (j in 1:nIy) {\n            binplot.3d(c(xI[i], xI[i+1]),\n                       c(yI[j], yI[j+1]),                       \n                       z[i,j], alpha=alpha, topcol=color.mat[i, j])\n                            \n        }\n    }\n        \n}\n\n\n\nbinplot.3d<-function(x,y,z,alpha=1,topcol=\"#ff0000\",sidecol=\"#aaaaaa\")\n{\n    save <- par3d(skipRedraw=TRUE)\n    on.exit(par3d(save))\n    \n    x1<-c(rep(c(x[1],x[2],x[2],x[1]),3),rep(x[1],4),rep(x[2],4))\n    z1<-c(rep(0,4),rep(c(0,0,z,z),4))\n    y1<-c(y[1],y[1],y[2],y[2],rep(y[1],4),rep(y[2],4),rep(c(y[1],y[2],y[2],y[1]),2))\n    x2<-c(rep(c(x[1],x[1],x[2],x[2]),2),rep(c(x[1],x[2],rep(x[1],3),rep(x[2],3)),2))\n    z2<-c(rep(c(0,z),4),rep(0,8),rep(z,8) )\n    y2<-c(rep(y[1],4),rep(y[2],4),rep(c(rep(y[1],3),rep(y[2],3),y[1],y[2]),2) )\n    rgl.quads(x1,z1,y1,col=rep(sidecol,each=4),alpha=alpha)\n    rgl.quads(c(x[1],x[2],x[2],x[1]),rep(z,4),c(y[1],y[1],y[2],y[2]),\n              col=rep(topcol,each=4),alpha=1) \n    rgl.lines(x2,z2,y2,col=\"#000000\")\n}\n\n\n###########################################################\n#                                                         #\n#                                                         #\n###########################################################\n# myImagePlot(fZ)\n\n# histMatrix <- ch04()    \n# jh <- joint.histogram(histMatrix, 3, 1) \n# x <- jh$fZ\n# myImagePlot(x)\n# \n## matrix visualization of a matrix \n## \n\n##myImagePlot(pZ, title=paste(\"Joint Histogram of Histograms: (\", DR, \n##                            kth, \", \", DR, jth,\")\", sep=\"\"))\n\n# x <- pZ\n# xlab <- \"\"\n# ylab <- \"\"\nmyImagePlot <- function(x, xlab, ylab, ...){\n    \n    \n    ## joint.hist <- list(breaks.x=Ig1, breaks.y=Ig2, pZ=pZ, fZ=fZ)\n    ## the input is x <- fZ, a matrix\n    \n    min <- min(x)\n    max <- max(x)\n    \n    yLabels <- rownames(x)\n    xLabels <- colnames(x)\n    title <- c()\n    \n    #\n    # check for additional function arguments\n    #\n    if( length(list(...)) ){\n        Lst <- list(...)\n        if( !is.null(Lst$zlim) ){\n            min <- Lst$zlim[1]\n            max <- Lst$zlim[2]\n        }\n        if( !is.null(Lst$yLabels) ){\n            yLabels <- c(Lst$yLabels)\n        }\n        if( !is.null(Lst$xLabels) ){\n            xLabels <- c(Lst$xLabels)\n        }\n        if( !is.null(Lst$title) ){\n            title <- Lst$title\n        }\n    }\n    \n    #\n    # check for null values\n    #\n    if( is.null(xLabels) ){\n        xLabels <- c(1:ncol(x))\n    }\n    if( is.null(yLabels) ){\n        yLabels <- c(1:nrow(x))\n    }\n    \n    layout(matrix(data=c(1,2), nrow=1, ncol=2), widths=c(5,1), heights=c(1,1))\n    \n    # Red and green range from 0 to 1 while Blue ranges from 1 to 0\n            \n    #ColorRamp <- rgb( seq(0,1,length=256),  # Red\n    #                  seq(0,1,length=256),  # Green\n    #                  seq(1,0,length=256))  # Blue\n   \n    \n    # Reverse Y axis\n    reverse <- nrow(x):1\n    yLabels <- yLabels[reverse]\n    x <- x[reverse,]\n        \n    ## (red ==> blue ) to (blue ==> red)\n    ColorRamp <- rainbow130(130)[130:1]\n                \n    ColorLevels <- seq(min, max, length=length(ColorRamp))\n        \n    \n    # Data Map\n    par(mar = c(3,5,2.5,2))\n    image(1:length(xLabels), 1:length(yLabels), t(x), col=ColorRamp, xlab=\"\",\n          ylab=\"\", axes=FALSE, zlim=c(min,max))\n        \n    xn <- rep(1:length(xLabels), each=nrow(x))\n    yn <- rep(1:length(yLabels), ncol(x))   \n    \n    \n    clu <- seq(min, max, length=4)\n    mat <- matrix(0, nrow=nrow(x), ncol=ncol(x))\n    for(h in 1:3){\n        mat[which(x >= clu[h] & x < clu[h+1]+1)] <- h   \n    }                 \n    text.color <- c(\"white\", \"black\", \"white\")        \n    text(xn, yn, round(x,3), col=text.color[mat], cex=0.8)\n    \n    if( !is.null(title) ){\n        title(main=title)\n    }\n    axis(BELOW <- 1, at=1:length(xLabels), labels=xLabels, cex.axis=1)\n    axis(LEFT <- 2, at=1:length(yLabels), labels=yLabels, las= HORIZONTAL <-1,\n         cex.axis=1)\n    \n    # Color Scale\n    par(mar = c(3,2.5,2.5,2))\n    image(1, ColorLevels,\n          matrix(data=ColorLevels, ncol=length(ColorLevels),nrow=1),\n          col=ColorRamp,\n          xlab=\"\",ylab=\"\",\n          xaxt=\"n\")        \n    \n    \n#    image(as.matrix(1:length(rainbow(130)), ncol=1), col=rainbow130(130))\n#    \n#    ColorRamp <- rainbow130(30)\n#    image(as.matrix(1:length(ColorRamp), ncol=1), col=ColorRamp)\n    \n    \n    layout(1)\n}\n\n\n\n\n###########################################################\n#                                                         #\n#                                                         #\n###########################################################\n### \n# linear combination for intervals\n###\nlinear.comb.intervals <- function(idata.x, beta){\n    ## idata: dim[n, p, 2], min=[n,p,1], max=[n, p, 2]\n    ## \n    ## beta = (b1 b2 ... bp)\n    ## z.a = \\sum beta (eta a + (1-eta) b)\n    ## z.b = \\sum beta ((1-eta) a + eta b)\n    \n    n <- dim(idata.x)[1]\n    p <- dim(idata.x)[2]    \n    beta <- matrix(beta, nrow=p)\n    beta.ncol <- ncol(beta)\n    idata.z <- array(0, dim=c(n, beta.ncol, 2))\n    \n    \n    for(i in 1:beta.ncol){\n        \n        at <- which(beta[,i]<0)\n        \n        idata.x.min <- idata.x[, ,1]\n        idata.x.max <- idata.x[, ,2]\n        idata.x.min[,at] <- idata.x[,at,2]\n        idata.x.max[,at] <- idata.x[,at,1]        \n        \n        idata.z[,i,1] <- idata.x.min%*%beta[,i]\n        idata.z[,i,2] <- idata.x.max%*%beta[,i]\n    }\n    idata.z    \n    \n}\n\n\n\n\n###########################################################\n#                                                         #\n#                                                         #\n###########################################################\n## input\n# xx <- 1:3  #3\n# zz <- 4:5  #2\n# yy <- 6:9  #4\n\n# list.seq.orig[1:3]\n\n# list.seq <- list(xx,yy,zz)\n# length(list.seq)\n\n#> list.seq\n#[[1]]\n#[1] 1 2 3 4 5 6 7\n#\n#[[2]]\n#[1] 1 2 3 4\n#\n#[[3]]\n#[1] 1 2 3 4 5\n#\n#[[4]]\n#[1] 1 2 3 4 5\n\n\n\n## output\n\n# index.seq(list.seq)\n# [,1] [,2] [,3]\n# [1,]    1    4    6\n# [2,]    1    4    7\n# [3,]    1    4    8\n# [4,]    1    4    9\n# ...\n# [22,]    3    5    7\n# [23,]    3    5    8\n# [24,]    3    5    9\n\n# list.seq <- list.seq[2:3]\n# index.seq(list.seq)\n\nindex.seq <- function(list.seq){\n    \n    (no.list <- length(list.seq))\n    \n    (zz <- list.seq[[no.list]])\n    (zr <- matrix(zz, ncol=1))\n    (base <- zr)\n    \n    # j <- 5\n    for(j in (no.list-1):1){            \n        \n        (nrow.zr <- nrow(zr))\n        \n        if((length(list.seq[[j]])-1)>1){\n            for(i in 1:(length(list.seq[[j]])-1)){\n                (zr <- rbind(zr, base))            \n            }    \n        }else{\n            (zr <- base)\n        }        \n        zr\n        (aa <- matrix(rep(list.seq[[j]], each=nrow.zr), ncol=1))\n        #cat(\"length(aa):\", length(aa), \"\\n\")\n        #cat(\"nrow(zr):\",nrow(zr), \"\\n\")\n        (zr <- cbind(aa, zr))        \n        base <- zr\n    }\n    zr    \n}\n\n\n###########################################################\n#                                                         #\n#                                                         #\n###########################################################  \n# linear combination for histograms\n# this version is very slow\n###\n# evec <- pca.evec\n\nlinear.comb.histograms <- function(histMatrix, evec){\n    \n    #histMatrix <- list(xI=xI, xP=xP, xO=xO, Bij=Bij)\n    #histMatrix\n    \n    xI <- histMatrix$xI\n    xP <- histMatrix$xP \n    xO <- histMatrix$xO \n    Bij <- histMatrix$Bij\n        \n    n <- nrow(Bij)\n    p <- ncol(Bij)\n        \n    no.beta <- ncol(evec)\n    \n    proj.xP <- vector(\"list\", n)\n    proj.xI <- vector(\"list\", n)    \n    proj.Bij <- matrix(0, nrow=n, ncol=no.beta)  ## number of bins\n        \n    \n    #xI[[i]][[j]] <- xh$breaks    \n    #xP[[i]][[j]] <- xh$counts/sum(xh$counts)    \n    #Bij[i, j] <- length(xh$counts)\n    \n    \n    Bi <- apply(Bij, 1, max)    \n    prodBij <- apply(Bij, 1, prod)\n    Ii.prime <- matrix(0, nrow=n, ncol=2*no.beta)\n    beta <- evec[,1:no.beta]                                      \n        \n    #i <- 1\n    for(i in 1:n){\n        cat(i, \"\")\n\n        ## index [u, p]\n        ## u=1,..., prodBij\n        ## index[1, ] = 1 3 5 8 means choose 1st subinterval of variable 1\n        ##                                   3                           2\n        ##                                   5                           3\n        ##                                   8                           4\n        list.seq <- vector(\"list\", p)\n        for(j in 1:p){\n            list.seq[[j]] <- 1:Bij[i, j]\n        }            \n        \n        \n        index <- index.seq(list.seq)\n        \n        \n        for(k in 1:no.beta){\n            proj.Bij[i, k] <- Bi[i]   \n            proj.xI[[i]][[k]] <- 1:(Bi[i]+1)\n            proj.xP[[i]][[k]] <- 1:Bi[i]\n        }\n        \n        \n        \n        Piu.prime <- rep(1, prodBij[i])            \n                            \n        # beta1      beta2\n        #[min max], [min max], u=1,..., prodBij\n        Iiu.prime <- matrix(0, ncol=2*no.beta, nrow=prodBij[i])\n        \n        #u <- 1\n        for(u in 1:prodBij[i]){\n            \n            \n            minI <- numeric(p)\n            maxI <- numeric(p)\n             \n            #j <- 1\n            for(j in 1:p){\n                Piu.prime[u] <- Piu.prime[u] * xP[[i]][[j]][index[u, j]]            \n            \n                minI[j] <- xI[[i]][[j]][index[u, j]]\n                maxI[j] <- xI[[i]][[j]][index[u, j]+1]                        \n                \n                ## linear combination\n                ## beta1\n                for(k in 1:no.beta){\n                    tau <- ifelse(beta[j,k]>0, 1, 0)            \n                    Iiu.prime[u,(k-1)*2+1] <- Iiu.prime[u, (k-1)*2+1] + beta[j, k]*\n                        (tau*minI[j] + (1-tau)*maxI[j])\n                    Iiu.prime[u,(k-1)*2+2] <- Iiu.prime[u, (k-1)*2+2] + beta[j, k]*\n                        ((1-tau)*minI[j] + tau*maxI[j])    \n                }                \n            }                                        \n            \n        }\n                                              \n        # 1st beta  2nd beta\n        # [min max] [min max]\n        for(k in 1:no.beta){\n            Ii.prime[i,(k-1)*2+1] <- min(Iiu.prime[,(k-1)*2+1])\n            Ii.prime[i,(k-1)*2+2] <- max(Iiu.prime[,(k-1)*2+2])\n            proj.xI[[i]][[k]] <- seq(Ii.prime[i, (k-1)*2+1], Ii.prime[i, (k-1)*2+2], \n                                     length=Bi[i]+1)                        \n        }\n                    \n                        \n        for(k in 1:no.beta){\n                    \n            for(b in 1:Bi[i]){\n                \n                ai <- proj.xI[[i]][[k]][b]\n                bi <- proj.xI[[i]][[k]][b+1]  \n                \n                piZ <- 0\n                for(u in 1:prodBij[i]){   \n                    \n                    ci <- Iiu.prime[u,(k-1)*2+1]  #min\n                    di <- Iiu.prime[u,(k-1)*2+2]  #max\n                    \n                    zIg <- 0\n                    \n                    if( !((bi <= ci) | (di <= ai))){                    \n                        #cat(\"b: \", b, \"\\n\")\n                        if((ai <= ci) & (ci <= bi) & (bi <= di)){  ## a c b d\n                            zIg <- abs(bi-ci)\n                        }\n                        if((ci <= ai) & (ai <= di) & (di <= bi)){ ## c a d b\n                            zIg <- abs(di-ai)\n                        }\n                        if((ai <= ci) & (ci <= di) & (di <= bi)){ ## a c d b\n                            zIg <- abs(di-ci)\n                        }\n                        if((ci <= ai) & (ai <= bi) & (bi <= di)){ ## c a b d\n                            zIg <- abs(bi-ai)\n                        }\n                        #cat(zIg,\"\\t\", abs(di-ci), \"\\t\", xP[[i]][[jth]][b], \"\\n\")            \n                        piZ <- piZ + zIg*Piu.prime[u]/abs(di-ci) \n                    }                            \n                }\n                \n                proj.xP[[i]][[k]][b] <- piZ\n                \n            }\n        }\n        \n    }    \n    \n    proj.histMatrix <- list(xI=proj.xI, xP=proj.xP, xO=xO, Bij=proj.Bij)\n    proj.histMatrix\n            \n                         \n}\n\n\n###########################################################\n#                                                         #\n#                                                         #\n###########################################################  \n# linear combination for histograms\nlinear.comb.histograms.2 <- function(histMatrix, evec){\n    \n    #histMatrix <- list(xI=xI, xP=xP, xO=xO, Bij=Bij)\n    #histMatrix\n    \n    xI <- histMatrix$xI\n    xP <- histMatrix$xP \n    xO <- histMatrix$xO \n    Bij <- histMatrix$Bij\n    \n    n <- nrow(Bij)\n    p <- ncol(Bij)\n    \n    no.beta <- ncol(evec)\n    \n    proj.xP <- vector(\"list\", n)\n    proj.xI <- vector(\"list\", n)    \n    proj.Bij <- matrix(0, nrow=n, ncol=no.beta)  ## number of bins\n    \n    \n    #xI[[i]][[j]] <- xh$breaks    \n    #xP[[i]][[j]] <- xh$counts/sum(xh$counts)    \n    #Bij[i, j] <- length(xh$counts)\n    \n    \n    Bi <- apply(Bij, 1, max)    \n    prodBij <- apply(Bij, 1, prod)\n    Ii.prime <- matrix(0, nrow=n, ncol=2*no.beta)\n    beta <- evec[,1:no.beta]\n    \n    \n    \n    #i <- 1\n    for(i in 1:n){\n        \n        ## index [u, p]\n        ## u=1,..., prodBij\n        ## index[1, ] = 1 3 5 8 means choose 1st subinterval of variable 1\n        ##                                   3                           2\n        ##                                   5                           3\n        ##                                   8                           4\n        list.seq <- vector(\"list\", p)\n        for(j in 1:p){\n            list.seq[[j]] <- 1:Bij[i, j]\n        }            \n        \n        index <- index.seq(list.seq)\n        \n        \n        for(k in 1:no.beta){\n            proj.Bij[i, k] <- Bi[i]   \n            proj.xI[[i]][[k]] <- 1:(Bi[i]+1)\n            proj.xP[[i]][[k]] <- 1:Bi[i]\n        }\n        \n        \n        \n        Piu.prime <- rep(1, prodBij[i])            \n        \n        # beta1      beta2\n        #[min max], [min max], u=1,..., prodBij\n        Iiu.prime <- matrix(0, ncol=2*no.beta, nrow=prodBij[i])\n        \n        #u <- 1\n        for(u in 1:prodBij[i]){\n            \n            \n            minI <- numeric(p)\n            maxI <- numeric(p)\n            \n            #j <- 1\n            for(j in 1:p){\n                Piu.prime[u] <- Piu.prime[u] * xP[[i]][[j]][index[u, j]]            \n                \n                minI[j] <- xI[[i]][[j]][index[u, j]]\n                maxI[j] <- xI[[i]][[j]][index[u, j]+1]                        \n                \n                ## linear combination\n                ## beta1\n                for(k in 1:no.beta){\n                    tau <- ifelse(beta[j,k]>0, 1, 0)            \n                    Iiu.prime[u,(k-1)*2+1] <- Iiu.prime[u, (k-1)*2+1] + beta[j, k]*\n                        (tau*minI[j] + (1-tau)*maxI[j])\n                    Iiu.prime[u,(k-1)*2+2] <- Iiu.prime[u, (k-1)*2+2] + beta[j, k]*\n                        ((1-tau)*minI[j] + tau*maxI[j])    \n                }                \n            }                                        \n            \n        }\n        \n        # 1st beta  2nd beta\n        # [min max] [min max]\n        for(k in 1:no.beta){\n            Ii.prime[i,(k-1)*2+1] <- min(Iiu.prime[,(k-1)*2+1])\n            Ii.prime[i,(k-1)*2+2] <- max(Iiu.prime[,(k-1)*2+2])\n            proj.xI[[i]][[k]] <- seq(Ii.prime[i, (k-1)*2+1], Ii.prime[i, (k-1)*2+2], \n                                     length=Bi[i]+1)                        \n        }\n        \n        \n        for(k in 1:no.beta){\n            \n            for(b in 1:Bi[i]){\n                \n                ai <- proj.xI[[i]][[k]][b]\n                bi <- proj.xI[[i]][[k]][b+1]  \n                \n                piZ <- 0\n                for(u in 1:prodBij[i]){   \n                    \n                    ci <- Iiu.prime[u,(k-1)*2+1]  #min\n                    di <- Iiu.prime[u,(k-1)*2+2]  #max\n                    \n                    zIg <- 0\n                    \n                    if( !((bi <= ci) | (di <= ai))){                    \n                        #cat(\"b: \", b, \"\\n\")\n                        if((ai <= ci) & (ci <= bi) & (bi <= di)){  ## a c b d\n                            zIg <- abs(bi-ci)\n                        }\n                        if((ci <= ai) & (ai <= di) & (di <= bi)){ ## c a d b\n                            zIg <- abs(di-ai)\n                        }\n                        if((ai <= ci) & (ci <= di) & (di <= bi)){ ## a c d b\n                            zIg <- abs(di-ci)\n                        }\n                        if((ci <= ai) & (ai <= bi) & (bi <= di)){ ## c a b d\n                            zIg <- abs(bi-ai)\n                        }\n                        #cat(zIg,\"\\t\", abs(di-ci), \"\\t\", xP[[i]][[jth]][b], \"\\n\")            \n                        piZ <- piZ + zIg*Piu.prime[u]/abs(di-ci) \n                    }                            \n                }\n                \n                proj.xP[[i]][[k]][b] <- piZ\n                \n            }\n        }\n        \n    }    \n    \n    proj.histMatrix <- list(xI=proj.xI, xP=proj.xP, xO=xO, Bij=proj.Bij)\n    proj.histMatrix\n    \n    \n}\n###########################################################\n#                                                         #\n#                                                         #\n###########################################################\n# within each bin, for each cluster, how many yi's in that bin\n#\n\nhist.class.number <- function(){\n\n    h <- hist(iris[,1])\n    B <- length(h$breaks)-1\n    x <- iris[,1]\n    \n    n <- length(x)\n    at <- numeric(n)\n    \n    hb <- h$breaks\n    Y.c <- as.factor(iris[,5])\n    \n    no.class <- length(levels(Y.c))\n    hist.cn <- matrix(0, nrow=no.class, ncol=B)\n    for(b in 1:B){    \n        \n        id <- which((x  > hb[b]) & (x <= hb[b+1]))\n        hist.cn[, b] <- table(Y.c[id])\n    }\n    hist.cn\n\n}\n\n###########################################################\n#                                                         #\n#                                                         #\n###########################################################\nCov.w.histMatrix <- function(histMatrix, y){\n    \n            \n    xI <- histMatrix$xI\n    xP <- histMatrix$xP \n    xO <- histMatrix$xO \n    Bij <- histMatrix$Bij\n    \n    n <- nrow(Bij)\n    p <- ncol(Bij)\n    \n        \n    minusmean <- function(row.data){\n        m <- row.data-x.mean\n    }\n    m.group <- function(data){\n        g.mean <- tapply(data, y, mean)\n    }\n    pro <- function(col.data){\n        col <- col.data*proportion\n    }\n    \n    no.group <- length(unique(y))\n    x.mean <- histMatrix.mean(histMatrix)\n    group.mean <- matrix(0, ncol=p, nrow=no.group)    \n            \n    \n    for(i in 1:no.group){\n        at <- which(y==i)        \n        xI.sub <- xI[at]\n        xP.sub <- xP[at]\n        xO.sub <- xO[at]\n        Bij.sub <- Bij[at,]\n        histMatrix.subset <- list(xI=xI.sub, xP=xP.sub, xO=xO.sub, Bij=Bij.sub)            \n        group.mean[i,] <- histMatrix.mean(histMatrix.subset)\n    }\n                \n    proportion <- summary(as.factor(y))/n\n    group.minus.mean <- t(as.matrix(apply(group.mean, 1, minusmean)))    \n    p.group.minus.mean <- apply(group.minus.mean, 2, pro)\n    weighted.cov <- (t(group.minus.mean)%*%p.group.minus.mean)\n    weighted.cov        \n}\n\n###########################################################\n#                                                         #\n#                                                         #\n###########################################################\nCov.w <- function(x, y){\n    \n    n <- dim(x)[1]\n    p <- dim(x)[2]        \n    minusmean <- function(row.data){\n        m <- row.data-x.mean\n    }\n    m.group <- function(data){\n        g.mean <- tapply(data, y, mean)\n    }\n    pro <- function(col.data){\n        col <- col.data*proportion\n    }\n    \n    no.group <- length(unique(y))\n    x.mean <- colMeans(x)\n    \n    group.mean <- apply(x, 2, m.group)\n    proportion <- summary(as.factor(y))/n\n    group.minus.mean <- t(as.matrix(apply(group.mean, 1, minusmean)))\n    \n    p.group.minus.mean <- apply(group.minus.mean, 2, pro)\n    weighted.cov <- (t(group.minus.mean)%*%p.group.minus.mean)\n    weighted.cov\n    \n    \n}\n###########################################################\n#                                                         #\n#                                                         #\n###########################################################\n## another way to compute Cov.w, answer is same as above\n#\nCov.w2 <- function(x, y){\n    \n    n <- dim(x)[1]\n    p <- dim(x)[2]                \n    H <- length(unique(y))\n    x.bar <- colMeans(x)\n    m.group <- function(data){\n        g.mean <- tapply(data, y, mean)\n    }    \n    x.bar.h <- apply(x, 2, m.group)\n    Ph <- summary(as.factor(y))/n\n    weighted.cov <- matrix(0, ncol=p, nrow=p)\n    for(i in i:p){\n        for(j in 1:i){\n            if(i==j){\n                s.xbar.h <- sum(Ph*x.bar.h[,i]^2)\n                weighted.cov[i,i] <- s.xbar.h - x.bar[i]^2\n            }else{\n                s.xbar.h <- sum(Ph*x.bar.h[,i]*x.bar.h[,j])                \n                weighted.cov[i,j] <- s.xbar.h - x.bar[i]*x.bar[j]\n                weighted.cov[j,i] <- weighted.cov[i,j]\n            }\n        }\n    }\n    \n    weighted.cov    \n}\n \n\n###########################################################\n# SIR                                                     #\n#                                                         #\n###########################################################\n# y={1,2,3,...}\nmy.sir <- function(x, y){\n    \n    \n    n <- dim(x)[1]\n    p <- dim(x)[2]        \n    x.cov <- cov(x)\n    \n    \n    ei <- eigen(x.cov)\n    pca.evec <- ei$vectors\n    eval <- ei$values\n    pca.eval <- eval/sqrt(sum(eval*eval))\n    \n    weighted.cov <- Cov.w(x, y)\n    \n    # generalized inverse\n    g.inv <- ginv(x.cov) \n    ei <- eigen(g.inv%*%weighted.cov)\n    \n    evec <- Re(ei$vectors)\n    eval <- Re(ei$values)\n    eval <- eval/sqrt(sum(eval*eval))\n    \n    \n    #reduction subspace    \n    #no.evc <- min(ncol(evec), 10)\n    #Z <- x %*% evec[, 1:no.evc]\n    \n    # print information\n    #cat(\"dim:\" , n , \" x \" , p , \"\\n\")\n    #cat(\"no.group:\", no.group ,\"\\n\")\n    \n    # pca\n    \n    \n    list(evec=evec, eval=eval, pca.evec=pca.evec, pca.eval=pca.eval)\n}\n\n\n###########################################################\n# SIR                                                     #\n#                                                         #\n###########################################################\n# y={1,2,3,...}\nmy.sir.histMatrix <- function(histMatrix, y){\n    \n    \n    xI <- histMatrix$xI\n    xP <- histMatrix$xP \n    xO <- histMatrix$xO \n    Bij <- histMatrix$Bij\n    \n    n <- nrow(Bij)\n    p <- ncol(Bij)\n    \n    \n    \n    \n    hM.cov <- histMatrix.cov(histMatrix)\n    \n    \n    ### PCA\n    \n    ei <- eigen(hM.cov$cov.EJD)\n    pca.evec <- ei$vectors\n    eval <- ei$values\n    pca.eval <- eval/sqrt(sum(eval*eval))    \n    \n    #evec <- pca.evec[,1:2]    \n    #proj.histMatrix.pca <- linear.comb.histograms(histMatrix, evec)\n    \n            \n    weighted.cov <- Cov.w.histMatrix(histMatrix, y)\n        \n    # generalized inverse\n    g.inv <- ginv(hM.cov$cov.EJD) \n    ei <- eigen(g.inv%*%weighted.cov)\n    \n    evec <- Re(ei$vectors)\n    eval <- Re(ei$values)\n    eval <- eval/sqrt(sum(eval*eval))\n        \n    #reduction subspace    \n    #no.evc <- min(ncol(evec), 10)\n    #Z <- x %*% evec[, 1:no.evc]\n    \n    # print information\n    #cat(\"dim:\" , n , \" x \" , p , \"\\n\")\n    #cat(\"no.group:\", no.group ,\"\\n\")\n    \n    # pca\n    \n    \n    list(evec=evec, eval=eval, pca.evec=pca.evec, pca.eval=pca.eval)\n}\n\n\n\n################################################################################\n# iSIR algorjthms                                                              #\n#                                                                              #\n################################################################################\n#\n# idata.x has been standardized\nhSIR.CM <- function(idata.x, y.C){\n    \n    xc <- Interval2Center(idata.x)        \n    isir.cm.ei <- my.sir(xc, y.C)        \n    isir.cm.ei\n    #idata.x.std <- interval.standardization(idata.x, method.id=1)            \n}\n\n \n\n###########################################################\n#                                                         #\n#                                                         #\n###########################################################\n#\nhSIR.QM <- function(idata.x, y.C, m=1){\n    \n    n <- dim(idata.x)[1]\n    q.obj <- Interval2Quantiles(idata.x, m)\n    \n    xQ <- q.obj$xQ        \n    y.C.ext <- numeric(nrow(xQ))\n    \n    for(i in 1:n){\n        y.C.ext[which(q.obj$index[,1]==i)] <- y.C[i]        \n    }    \n    \n    isir.q.ei <- my.sir(xQ, y.C.ext)\n    \n    list(ei=isir.q.ei, xQ=xQ, index=q.obj$index)\n    \n}\n \n\n###########################################################\n# Symbolic Covariance: EJD, GQ, SPT                       #\n#                                                         #\n###########################################################\n# symbolic covariance method\n# input: idata.x idata.y\nhSIR.SC <- function(idata.x, y.C){   \n    \n    n <- dim(idata.x)[1]\n    p <- dim(idata.x)[2]\n    no.group <- length(unique(y.C))\n    \n    \n    # Find the matrix of centers, xbaru, and the total sample mean, xbar\n    # xbaru <- matrix(0, m, p)    \n    \n    \n    ################################## \n    #  symbolic sample mean          #\n    ##################################     \n    xbaru <- (idata.x[, ,1] + idata.x[, ,2])/2        \n    xbar <- colMeans(xbaru)\n    xbar ## centered, so approx 0, \n    \n    ################################\n    # Sjj'=QQ                      #\n    ################################\n    # (12) sign matrix of the correlations\n    Gu = matrix(-1, n, p)\n    \n    for (j in 1:p){\n        for (u in 1:n){ \n            if (xbaru[u,j] > xbar[j])  \n                Gu[u,j] = 1\n        }\n    }\n    \n    Qu = matrix(0, n, p)\n    for (j in 1:p){\n        for (u in 1:n){ \n            Qu[u,j] = (idata.x[u,j,1] - xbar[j])^2 + \n                (idata.x[u,j,1] - xbar[j])*(idata.x[u,j,2] - xbar[j]) + \n                (idata.x[u,j,2] - xbar[j])^2\n        }\n    }\n    \n    \n    Cov.EJD <- matrix(0, p, p)\n    Cov.GQ <- matrix(0, p, p)\n    Cov.SPT <- matrix(0, p, p)\n    \n    \n    \n    for(i in 1:p){    \n        for(j in 1:i){          \n            \n            ################################\n            # Sjj'=1/4n...                 #\n            ################################\n            if(i==j){\n                a <- sum(idata.x[, i,2]^2 + idata.x[, i,1]*idata.x[, i,2]+idata.x[,i,1]^2)\n                b <- (sum(idata.x[, i,1] + idata.x[, i,2]))^2                \n                Cov.EJD[i, j] <- a/(3*n)-b/(4*n^2)\n            }else{                            \n                a <- sum(idata.x[, i,1] + idata.x[, i,2])\n                b <- sum(idata.x[, j,1] + idata.x[, j,2])\n                c <- sum((idata.x[, i,1] + idata.x[, i,2])*(idata.x[, j,1] + idata.x[, j,2]))        \n                Cov.EJD[i, j] <- c/(4*n)-(a*b)/(4*n^2)\n                Cov.EJD[j, i] <- Cov.EJD[i, j]\n            }\n            \n            ################################\n            # Sjj'=GQ                      #\n            ################################\n            if(i==j){\n                a <- sum(idata.x[, i,2]^2 + idata.x[, i,1]*idata.x[, i,2]+idata.x[,i,1]^2)\n                b <- (sum(idata.x[, i,1] + idata.x[, i,2]))^2                \n                Cov.GQ[i, j] <- a/(3*n)-b/(4*n^2)\n            }else{\n                Cov.GQ[i,j] <- sum((Gu[,i]*Gu[,j]*sqrt(Qu[,i]*Qu[,j])))/(3*n)\n                Cov.GQ[j,i] <- Cov.GQ[i,j]                \n            }\n            ################################\n            # Sjj'=SPT                     #\n            ################################\n            if(i==j){\n                a <- sum(idata.x[, i,2]^2 +idata.x[, i,1]*idata.x[, i,2]+idata.x[, i,1]^2)\n                b <- (sum(idata.x[, i,1] + idata.x[, i,2]))^2                \n                Cov.SPT[i, j] <- a/(3*n)-b/(4*n^2)                \n            }else{\n                a2 <- (idata.x[, i,1] - xbar[i])*(idata.x[, j,1] - xbar[j])\n                ab <- (idata.x[, i,1] - xbar[i])*(idata.x[, j,2] - xbar[j]) +\n                    (idata.x[, i,2] - xbar[i])*(idata.x[, j,1] - xbar[j])\n                b2 <- (idata.x[, i,2] - xbar[i])*(idata.x[, j,2] - xbar[j])                       \n                Cov.SPT[i, j] <- sum(2*a2 + ab + 2*b2)/(6*n)\n                Cov.SPT[j, i] <- Cov.SPT[i, j]\n                \n            }\n            \n            \n        }\n    }\n    \n    #print(round(Cov.GQ, 4))\n    #print(round(Cov.EJD, 4))    \n    #print(round(Cov.SPT, 4))    \n    \n    ################################\n    #                              #\n    ################################\n    \n    weighted.cov <- Cov.w.interval(idata.x, y.C) \n    \n    # generalized inverse: EJD\n    g.inv <- ginv(Cov.EJD)     \n    ei <- eigen(g.inv%*%weighted.cov)    \n    evec.EJD <- Re(ei$vectors)\n    eval.EJD <- Re(ei$values)\n    eval.EJD <- eval.EJD/sqrt(sum(eval.EJD*eval.EJD))\n    \n    \n    # generalized inverse: SPT\n    g.inv <- ginv(Cov.SPT)     \n    ei <- eigen(g.inv%*%weighted.cov)    \n    evec.SPT <- Re(ei$vectors)\n    eval.SPT <- Re(ei$values)\n    eval.SPT <- eval.SPT/sqrt(sum(eval.SPT*eval.SPT))\n    \n    \n    # generalized inverse: GQ\n    g.inv <- ginv(Cov.GQ)     \n    ei <- eigen(g.inv%*%weighted.cov)    \n    evec.GQ <- Re(ei$vectors)\n    eval.GQ <- Re(ei$values)\n    eval.GQ <- eval.GQ/sqrt(sum(eval.GQ*eval.GQ))\n    \n    \n    ei <- eigen(Cov.EJD)\n    pca.evec.EJD <- ei$vectors\n    eval <- ei$values\n    pca.eval.EJD <- eval/sqrt(sum(eval*eval))\n    \n    ei <- eigen(Cov.GQ)\n    pca.evec.GQ <- ei$vectors\n    eval <- ei$values\n    pca.eval.GQ <- eval/sqrt(sum(eval*eval))\n    \n    ei <- eigen(Cov.SPT)\n    pca.evec.SPT <- ei$vectors\n    eval <- ei$values\n    pca.eval.SPT <- eval/sqrt(sum(eval*eval))\n    \n    \n    #reduction subspace    \n    #no.evc <- min(ncol(evec), 10)\n    #Z <- x %*% evec[, 1:no.evc]\n    \n    # print information\n    #cat(\"dim:\" , n , \" x \" , p , \"\\n\")\n    #cat(\"no.group:\", no.group ,\"\\n\")\n    \n    list(evec.EJD=evec.EJD, eval.EJD=eval.EJD,            \n                evec.GQ=evec.GQ, eval.GQ=eval.GQ,                \n                pca.evec.EJD=pca.evec.EJD, pca.eval.EJD=pca.eval.EJD,            \n                pca.evec.GQ=pca.evec.GQ, pca.eval.GQ=pca.eval.GQ                \n    )\n}\n\n      \n###########################################################\n# get y                                                   #\n###########################################################\n#class from 1,2,3,...\ngetY <- function(xdata, no.cluster, slicing.method=\"h\"){\n    \n    n <- nrow(as.matrix(xdata))\n    h <- no.cluster    \n    y.C <- rep(0, n)\n    \n    if(slicing.method==\"h\"){    \n        ns <- floor(n/h)   \n        group.number <- rep(ns, h)        \n        hk <- floor(n-h*ns)         \n        if(hk!=0){\n            group.number[1:hk] <- group.number[1:hk] + rep(1, hk)\n        }\n        ylabel <- rep(1:h, group.number)\n        # xtata <- ydata\n        #[ylabel, sort[ydata]\n        # ylabel[rank(ydata)], ydata=sort(ydata)[rank(data)]\n        y.C <- ylabel[rank(xdata)]         \n    }\n    \n    if(slicing.method==\"kms\"){\n        KM <- kmeans(xdata, no.cluster)\n        y.C <- KM$cluster\n    }    \n    \n    y.C        \t\n    \n}\n\n\n\n###########################################################\n# get y (slices) using KMS for interval data              #\n###########################################################\n#output: class from 1,2,3,...\n#input: idata\n# if input is idata.x, then kms\n# if input is idata.y, then h\ngetXY.interval <- function(idata.x, idata.y, no.cluster){\n    \n    len.y <- length(idata.y) #if there is no idata.y input, set idata.y <- 0\n    \n    if(len.y == 1){\n        y.C <- getY.interval(idata.x, no.cluster, method=\"kms\")\n    }else{\n        y.C <- getY.interval(idata.y, no.cluster, method=\"h\")\n    }\n    y.C\n    \n}\n\ngetY.interval <- function(idata, no.cluster, method=\"h\"){\n    \n    ## mydist <- dist.Symbolic(idata, type=\"M\")        \n    n <- dim(idata)[1]\n    p <- dim(idata)[2]\n    \n    \n    h <- no.cluster    \n    y.C <- rep(0, n)\n    \n    \n    #for idata.y or #for idata.x    \n    xc <- yc <- (idata[,,1]+idata[,,2])/2\n    \n    if(method==\"h\"){    \n        ns <- floor(n/no.cluster)   \n        group.number <- rep(ns, no.cluster)        \n        hk <- floor(n-no.cluster*ns)         \n        if(hk!=0){\n            group.number[1:hk] <- group.number[1:hk] + rep(1, hk)\n        }\n        ylabel <- rep(1:no.cluster, group.number)\n        # xtata <- ydata\n        #[ylabel, sort[ydata]\n        # ylabel[rank(ydata)], ydata=sort(ydata)[rank(data)]\n        y.C <- ylabel[rank(yc)]         \n    }\n    \n    if(method==\"kms\"){#kmeans on xc\n        KM <- kmeans(xc, no.cluster, iter.max = 50)\n        y.C <- KM$cluster\n    }\n    \n    if(method==\"dy\"){\n        mydist <- dist(xmean, method = \"minkowski\", p=2)    \n        y.C <- DClust(mydist, cl=no.cluster, iter=100)\n    }\n    \n    if(method==\"Dis\"){\n        mydist <- dist.Symbolic(idata)\n        #mydist <- dist.Symbolic(sdt, type=\"H\")\n        y.C <- DClust(mydist, cl=no.cluster, iter=100) #cluste=[1 2 3 4 5 ...]\n        \n    }            \n    \n    \n    y.C            \n    \n}\n\n\n \n\n###########################################################\n#                                                         #\n###########################################################\nrange.scale <- function(x){   \n    xx <- (x-min(x))/(max(x)-min(x))\n    xx\n} \n\n\n###########################################################\n#                                                         #\n###########################################################\n#   SVD\ngetSVD <- function(M, ratio=0.95, nd=999, at.least=FALSE){\n    \n    #M should be centered  \n    M.svd <- svd(M)\n    D <- diag(M.svd$d)    \n    if(nd==999){\n        ne <- 1\n        sumev <- sum(M.svd$d)\n        while((sum(M.svd$d[1:ne])/sumev) < ratio){\n            ne <- ne+1\n        }\n    }else{\n        ne <- nd\n    }\n    cat(\"svd: \", ne, \"\\n\")\n    #M.reduce <- M.svd$u[,1:ne] %*% D[1:ne, 1:ne] %*% t(M.svd$v)[1:ne,]      \n    # X=USV'\n    # if columns(M) were centering, \n    # eigenvalues(X'X)=s^2\n    # X'X=VS^2V'\n    # U=XVS^{-1}\n    # V: Pcs\n    # US: PC scores    \n    if(ne==1){\n        if(at.least){\n            ne <- max(10, ne)\n            M.reduce <- M.svd$u[,1:ne] %*% D[1:ne, 1:ne]\n        }else{\n            M.reduce <- M.svd$u[,1:2] %*% D[1:2, 1:2]\n        }\n    }else{\n        if(at.least){\n            ne <- max(10, ne)\n        }\n        M.reduce <- M.svd$u[,1:ne] %*% D[1:ne, 1:ne]\n    }\n}\n\n\n\n\n###########################################################\n#                                                         #\n###########################################################\ns.center <- function(center, n, order){\n    order <- numeric(center)\n    for(i in 1:center){\n        order[i] <- floor((n/center)*(i-1))+1\n    }\n    order\n}\n\n\n\n\n###########################################################\n#                                                         #\n###########################################################\n#\n# ref: http://gifi.stat.ucla.edu/psychoR/derivatives/derivatives.pdf\n#\n# gevd compute the generalized eigenvalue\n# decomposition for ( a , b)\ngevd <- function(a , b=diag(nrow(a))){\n    bs <- mfunc(b , function(x) ginvx(sqrt(x)))\n    ev <- eigen ( bs%*%a%*%bs )\n    return(list(values=ev$values, vectors=bs%*%ev$vectors))\n}\n# ginvx i s a helper to compute reciprocals\nginvx <- function ( x ) { ifelse ( x==0,0,1/x ) }\n# mfunc i s a helper to compute matrix functions\nmfunc <- function ( a , fn=sqrt ) {\n    e <- eigen(a); \n    y <- e$vectors ; v <- e$values\n    return(tcrossprod (y%*%diag(fn(v)),y))\n}\n\n\n\n###########################################################\n#                                                         #\n#                                                         #\n###########################################################\n\nhistogram.standardization <- function(idata.x, method.id=1){\n    \n    n <- dim(idata.x)[1]\n    p <- dim(idata.x)[2]\n    idata.x.std <- array(0, dim=c(n, p, 2))\n    \n    \n    ## 1: centers\n    if(method.id==1){\n        xc <- (idata.x[,,1] + idata.x[,,2])/2\n        xbar <- colMeans(xc)\n        xsd <- apply(xc, 2, sd)    \n        for(j in 1:p){\n            idata.x.std[,j,1] <- (idata.x[,j,1]-xbar[j])/xsd[j]\n            idata.x.std[,j,2] <- (idata.x[,j,2]-xbar[j])/xsd[j]            \n        }\n    }\n    ## distributional approaches: EJD, GQ, SPT\n    if(method.id==2){    \n        xc <- (idata.x[,,1] + idata.x[,,2])/2\n        xbar <- colMeans(xc)\n        xsd <- numeric(p)\n        for(j in 1:p){\n            a <- sum(idata.x[,j,1]^2 + idata.x[,j,1]*idata.x[,j,2]+idata.x[,j,2]^2)\n            b <- (sum(idata.x[,j,1] + idata.x[,j,2]))^2                \n            xsd[j] <- sqrt(a/(3*n)-b/(4*n^2))    \n        }    \n        for(j in 1:p){\n            idata.x.std[,j,1] <- (idata.x[,j,1]-xbar[j])/xsd[j]\n            idata.x.std[,j,2] <- (idata.x[,j,2]-xbar[j])/xsd[j]            \n        }\n    }\n    ## INP\n    if(method.id==3){\n        xc <- (idata.x[,,1] + idata.x[,,2])/2\n        xbar <- colMeans(xc)\n        xsd <- numeric(p)\n        for(j in 1:p){    \n            a <- sum(idata.x[,j,2]^2 + idata.x[,j,1]*idata.x[,j,2]+idata.x[,j,1]^2)\n            xsd[j] <- sqrt(a/(3*n))\n        }\n        for(j in 1:p){\n            idata.x.std[,j,1] <- (idata.x[,j,1]-xbar[j])/xsd[j]\n            idata.x.std[,j,2] <- (idata.x[,j,2]-xbar[j])/xsd[j]            \n        }\n        \n    }\n    ## DIS\n    if(method.id==4){        \n        xi.a.bar <- colMeans(idata.x[,,1])\n        xi.b.bar <- colMeans(idata.x[,,2])\n        \n        xc <- Interval2Center(idata.x)\n        xr <- Interval2Midrange(idata.x)\n        \n        xc.bar <- colMeans(xc)\n        xr.bar <- colMeans(xr)\n        \n        xsd <- numeric(p)        \n        \n        for(j in 1:p){            \n            dis <- abs(xc[,j]-xc.bar[j])+abs(xr[,j]-xr.bar[j])\n            xsd[j] <- sqrt(sum(dis^2)/n)                \n        }                           \n        for(j in 1:p){            \n            idata.x.std[,j,1] <- (idata.x[,j,1]-xi.a.bar[j])/xsd[j]\n            idata.x.std[,j,2] <- (idata.x[,j,2]-xi.b.bar[j])/xsd[j]            \n        }\n        xbar <- array(0, dim=c(1,p,2))\n        xbar[,,1] <- xi.a.bar\n        xbar[,,2] <- xi.b.bar\n        \n    }\n    idata.x.std\n    \n    \n    #list(idata.x.std=idata.x.std, xbar=xbar, xsd=xsd)\n}\n \n\n\n\n#jpeg(filename = \"..\\\\latex\\\\Slices\\\\Beamer-2\\\\iSIR.CM.jpg\", width = 480, height = 240, quality = 100)\n#par(mfrow=c(1,2),oma=c(0,0,2,0), mar=c(2,2,0,1))\n#plot.Interval.2d(idata.z.cm, ycolors)\n#plot.polytope.2d(isir.cm.vdim, cp, ycolors) \n#title(\"iSIR.CM\", outer=TRUE)\n#dev.off()\n\n\nresetPar <- function() {\n    dev.new()\n    op <- par(no.readonly = TRUE)\n    dev.off()\n    op\n}\n\n",
    "created" : 1455971951117.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "345492841",
    "id" : "9BD502C3",
    "lastKnownWriteTime" : 1402669604,
    "path" : "C:/Users/TSR/Desktop/article/Rcode-SIR-Histogram/histoSIR-Source.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "type" : "r_source"
}