mean(v)
v=rep(0,1000)
for (i in 1:1000){
v[i]=mstep(a=1,b=1,m=9,n=100)[[2]]
}
mean(v)
mstep(a=1,b=1,m=9,n=100)
mstep(a=1,b=1,m=9,n=100)
mstep(a=1,b=1,m=9,n=100)[2]
mstep(a=1,b=1,m=9,n=100)[2]
mstep(a=1,b=1,m=9,n=100)[2]
mstep(a=1,b=1,m=9,n=100)[2]
mstep(a=1,b=1,m=9,n=100)[2]
mstep(a=1,b=1,m=9,n=100)[2]
mstep(a=1,b=1,m=9,n=100)[2]
mstep(a=1,b=1,m=9,n=100)[2]
mstep(a=1,b=1,m=9,n=100)[2]
mstep(a=1,b=1,m=9,n=100)[2]
mstep(a=1,b=1,m=9,n=100)[2]
mstep(a=1,b=1,m=9,n=100)[2]
mstep(a=1,b=1,m=9,n=100)[2]
mstep(a=1,b=1,m=9,n=100)[2]
mstep(a=1,b=1,m=9,n=100)[2]
mstep(a=1,b=1,m=9,n=100)[2]
mstep(a=1,b=1,m=9,n=100)[2]
mstep(a=1,b=1,m=9,n=100)[2]
mstep(a=1,b=1,m=9,n=100)[2]
mstep(a=1,b=1,m=9,n=100)[2]
mstep(a=1,b=1,m=9,n=100)[2]
mstep(a=1,b=1,m=9,n=100)[2]
mstep(a=1,b=1,m=9,n=100)[2]
mstep(a=1,b=1,m=9,n=100)[2]
mstep(a=1,b=1,m=9,n=100)[2]
mstep(a=1,b=1,m=9,n=100)[2]
mstep(a=1,b=1,m=9,n=100)[2]
Rprof()
invisible(  mstep(a=1,b=1,m=9,n=100)  )
Rprof(NULL)
summaryRprof()
mreducestep(a=1,b=1,m=9,n=100)
mreducestep(a=1,b=1,m=9,n=100)
mreducestep(a=1,b=1,m=9,n=100)
mreducestep(a=1,b=1,m=9,n=100)
mreducestep(a=1,b=1,m=9,n=100)
mreducestep(a=1,b=1,m=9,n=100)
mreducestep(a=1,b=1,m=9,n=100)
mreducestep(a=1,b=1,m=9,n=100)
mreducestep(a=1,b=1,m=9,n=100)
mreducestep(a=1,b=1,m=9,n=100)
mreducestep(a=1,b=1,m=9,n=100)
mreducestep(a=1,b=1,m=9,n=100)
mreducestep(a=1,b=1,m=9,n=100)
Rprof()
invisible(
v=rep(0,1000)
for (i in 1:1000){
v[i]=mstep(a=1,b=1,m=9,n=100)[[2]]
}
mean(v)  )
Rprof(NULL)
summaryRprof()
Rprof()
invisible(  mstep(a=1,b=1,m=31,n=1000)  )
Rprof(NULL)
summaryRprof()
Nkfail=function(a,b,n,N){
rb=rbeta(n = n,shape1 = a,shape2 = b)
list=c()
p=0;count=0
for (i in 1:n){
taget=rb[i]
if (length(list)>=n){break}
for (j in 1:n){
if (length(list)>=n){break}
ru=runif(n)
p=ifelse(test = taget>=ru[j],"S","F")
list=c(list,p)
if (length(list)==N & p=='S') {next}
if (taget<ru[j]) {break}
}
}
list
count=sum(list=="F")/n
list(log=list,persent=count)
}
Nkfail(a=1,b=1,n=100,N=50)
v=rep(0,1000)
for (i in 1:1000){
v[i]=Nkfail(a=1,b=1,n=100,N=50)[[2]]
}
mean(v)
v=rep(0,1000)
for (i in 1:1000){
v[i]=Nkfail(a=1,b=1,n=100,N=50)[[2]]
}
mean(v)
v=rep(0,1000)
for (i in 1:1000){
v[i]=mreducestep(a=1,b=1,m=9,n=100)[[2]]
}
mean(v)
v=rep(0,1000)
for (i in 1:1000){
v[i]=mreducestep(a=1,b=1,m=9,n=100)[[2]]
}
mean(v)
v=rep(0,1000)
for (i in 1:1000){
v[i]=mreducestep(a=1,b=1,m=9,n=100)[[2]]
}
mean(v)
summaryRprof()
mstep=function(a,b,m,n){
rb=rbeta(n = n,shape1 = a,shape2 = b)
list=c()
mtotal=c()
p=0
count=0
for (i in 1:n){
taget=rb[i]
scount=0
if (length(list)>=n){break}
for (j in 1:n){
if (length(list)>=n){break}
###如果換手臂的次數大於m,則找出成功率最高的做下去
if (length(mtotal)==m) {taget=rb[which.max(mtotal)]}
ru=runif(n)
###從beta分配抽出來的如果比uniform大，則給S,反之給F
if (taget>=ru[j]) p="S"
else p="F"
###收集每次的實驗結果
list=c(list,p)
###累計該手臂成功的次數
if (taget>=ru[j]) {scount=scount+1}
####使用的手臂在m個以下，而且該次實驗是失敗的，記錄下該次實驗的成功總次數
if (taget<ru[j] & length(mtotal)<m) {
mtotal=c(mtotal,scount)
break
}
}
}
persent=sum(list=="F")/n
list(list,persent,mtotal)
}
Rprof()
invisible(  mstep(a=1,b=1,m=31,n=1000)  )
Rprof(NULL)
summaryRprof()
v=rep(0,1000)
for (i in 1:1000){
v[i]=mstep(a=1,b=1,m=9,n=100)[[2]]
}
mean(v)
v=rep(0,1000)
for (i in 1:1000){
v[i]=mstep(a=1,b=1,m=31,n=1000)[[2]]
}
mean(v)
Nkfail=function(a,b,n,N){
rb=rbeta(n = n,shape1 = a,shape2 = b)
list=c()
mtotal=c()
p=0
count=0
x=1
for (i in 1:n){
taget=rb[i]
scount=0
if (length(list)>=n){break}
for (j in 1:n){
if (length(list)>=n){break}
if (length(mtotal)>=N & x=1) {taget=rb[which.max(mtotal)];x=0}
###如果換手臂的次數大於m,則找出成功率最高的做下去
#if (length(list)>=N) {taget=rb[which.max(mtotal)]}
ru=runif(n)
###從beta分配抽出來的如果比uniform大，則給S,反之給F
if (taget>=ru[j]) p="S"
else p="F"
###收集每次的實驗結果
list=c(list,p)
###累計該手臂成功的次數
if (taget>=ru[j]) {scount=scount+1}
if (taget<ru[j] & x=1) {
mtotal=c(mtotal,scount)
break
}
}
}
persent=sum(list=="F")/n
list(list,persent,mtotal)
}
Nkfail=function(a,b,n,N){
rb=rbeta(n = n,shape1 = a,shape2 = b)
list=c()
mtotal=c()
p=0
count=0
x=1
for (i in 1:n){
taget=rb[i]
scount=0
if (length(list)>=n){break}
for (j in 1:n){
if (length(list)>=n){break}
if (length(mtotal)>=N & x==1) {taget=rb[which.max(mtotal)];x=0}
###如果換手臂的次數大於m,則找出成功率最高的做下去
#if (length(list)>=N) {taget=rb[which.max(mtotal)]}
ru=runif(n)
###從beta分配抽出來的如果比uniform大，則給S,反之給F
if (taget>=ru[j]) p="S"
else p="F"
###收集每次的實驗結果
list=c(list,p)
###累計該手臂成功的次數
if (taget>=ru[j]) {scount=scount+1}
if (taget<ru[j] & x==1) {
mtotal=c(mtotal,scount)
break
}
}
}
persent=sum(list=="F")/n
list(list,persent,mtotal)
}
Nkfail(a=1,b=1,n=100,N=50)
v=rep(0,1000)
for (i in 1:1000){
v[i]=Nkfail(a=1,b=1,n=100,N=50)[[2]]
}
mean(v)
Nkfail=function(a,b,n,N){
rb=rbeta(n = n,shape1 = a,shape2 = b)
list=c()
mtotal=c()
p=0
count=0
x=1
for (i in 1:n){
taget=rb[i]
scount=0
if (length(list)>=n){break}
for (j in 1:n){
if (length(list)>=n){break}
if (length(mtotal)>=N & x==1) {taget=rb[which.max(mtotal)];x=0}
###如果換手臂的次數大於m,則找出成功率最高的做下去
#if (length(list)>=N) {taget=rb[which.max(mtotal)]}
ru=runif(n)
###從beta分配抽出來的如果比uniform大，則給S,反之給F
if (taget>=ru[j]) {
p="S"
scount=scount+1
}
else p="F"
###收集每次的實驗結果
list=c(list,p)
if (taget<ru[j] & x==1) {
mtotal=c(mtotal,scount)
break
}
}
}
persent=sum(list=="F")/n
list(list,persent,mtotal)
}
Nkfail(a=1,b=1,n=100,N=50)
Nkfail(a=1,b=1,n=100,N=50)
Nkfail(a=1,b=1,n=100,N=50)
Nkfail(a=1,b=1,n=100,N=50)
Nkfail(a=1,b=1,n=100,N=50)
Nkfail(a=1,b=1,n=100,N=50)
Nkfail(a=1,b=1,n=100,N=50)
Nkfail(a=1,b=1,n=100,N=50)
Nkfail(a=1,b=1,n=100,N=50)
Nkfail=function(a,b,n,N){
rb=rbeta(n = n,shape1 = a,shape2 = b)
list=c()
mtotal=c()
p=0
count=0
#####x=1是代表還未找到做到底的手臂,x=0是代表找到了
x=1
for (i in 1:n){
taget=rb[i]
scount=0
if (length(list)>=n){break}
for (j in 1:n){
if (length(list)>=n){break}
if (length(mtotal)>=N & p=="F" & x==1) {taget=rb[which.max(mtotal)];x=0}
ru=runif(n)
###從beta分配抽出來的如果比uniform大，則給S,反之給F
if (taget>=ru[j]) {
p="S"
scount=scount+1
}
else p="F"
###收集每次的實驗結果
list=c(list,p)
if (taget<ru[j] & x==1) {
mtotal=c(mtotal,scount)
break
}
}
}
persent=sum(list=="F")/n
list(list,persent,mtotal)
}
Nkfail(a=1,b=1,n=100,N=50)
Nkfail(a=1,b=1,n=100,N=50)
Nkfail(a=1,b=1,n=100,N=50)
Nkfail(a=1,b=1,n=100,N=50)
Nkfail(a=1,b=1,n=100,N=50)
Nkfail(a=1,b=1,n=100,N=50)
Nkfail=function(a,b,n,N){
rb=rbeta(n = n,shape1 = a,shape2 = b)
list=c()
mtotal=c()
p=0
count=0
#####x=1是代表還未找到做到底的手臂,x=0是代表找到了
x=1
for (i in 1:n){
taget=rb[i]
scount=0
if (length(list)>=n){break}
for (j in 1:n){
if (length(list)>=n){break}
#####
if (length(mtotal)>=N & p=="F" & x==1) {taget=rb[which.max(mtotal)];x=0}
if (length(mtotal)==N & p=="S") x=0
ru=runif(n)
###從beta分配抽出來的如果比uniform大，則給S,反之給F
if (taget>=ru[j]) {
p="S"
scount=scount+1
}
else p="F"
###收集每次的實驗結果
list=c(list,p)
if (taget<ru[j] & x==1) {
mtotal=c(mtotal,scount)
break
}
}
}
persent=sum(list=="F")/n
list(list,persent,mtotal)
}
Nkfail(a=1,b=1,n=100,N=50)
Nkfail(a=1,b=1,n=100,N=50)
Nkfail(a=1,b=1,n=100,N=50)
Nkfail(a=1,b=1,n=100,N=50)
Nkfail(a=1,b=1,n=100,N=50)
Nkfail(a=1,b=1,n=100,N=50)
v=rep(0,1000)
for (i in 1:1000){
v[i]=Nkfail(a=1,b=1,n=100,N=50)[[2]]
}
mean(v)
kfail=function(a,b,n,alpha,t){
if (t==1){rb=createbeta(n,alpha)}
else {rb=rbeta(n = n,shape1 = a,shape2 = b)}
list=c()
p=0
count=0
for (i in 1:n){
taget=rb[i]
if (length(list)>=n){break}
for (j in 1:n){
if (length(list)>=n){break}
ru=runif(n)
p=ifelse(test = taget>=ru[j],"S","F")
list=c(list,p)
if (taget<ru[j]) {break}
}
}
list
count=sum(list=="F")/n
list(log=list,persent=count)
}
kfail=function(a=1,b=1,n=100,alpha=0.1,t=1){
if (t==1){rb=createbeta(n,alpha)}
else {rb=rbeta(n = n,shape1 = a,shape2 = b)}
list=c()
p=0
count=0
for (i in 1:n){
taget=rb[i]
if (length(list)>=n){break}
for (j in 1:n){
if (length(list)>=n){break}
ru=runif(n)
p=ifelse(test = taget>=ru[j],"S","F")
list=c(list,p)
if (taget<ru[j]) {break}
}
}
list
count=sum(list=="F")/n
list(log=list,persent=count)
}
for (i in 1:100){
a=kfail(a=1,b=1,n=200,t=0)$persent
v=v+a
}
v/100
v=0
for (i in 1:100){
a=kfail(a=1,b=1,n=200,t=0)$persent
v=v+a
}
v/100
v=0
for (i in 1:100){
a=kfail(a=1,b=1,n=200,t=0)$persent
v=v+a
}
v/100
v=0
for (i in 1:100){
a=kfail(a=1,b=1,n=200,t=0)$persent
v=v+a
}
v/100
v=0
for (i in 1:100){
a=kfail(a=1,b=1,n=200,t=0)$persent
v=v+a
}
v/100
kfail=function(a=1,b=1,n=100,alpha=0.1,t=1){
if (t==1){rb=createbeta(n,alpha)}
else {rb=rbeta(n = n,shape1 = a,shape2 = b)}
list=c()
p=0
count=0
for (i in 1:n){
taget=rb[i]
if (length(list)>=n){break}
for (j in 1:n){
if (length(list)>=n){break}
ru=runif(n)
p=ifelse(test = taget>=ru[j],"S","F")
list=c(list,p)
if (taget<ru[j]) {break}
}
}
list
count=sum(list=="F")/n
list(log=list,persent=count)
}
for (i in 1:100){
a=kfail(a=1,b=1,n=200,t=0)$persent
v=v+a
}
v/100
v=0
for (i in 1:100){
a=kfail(a=1,b=1,n=200,t=0)$persent
v=v+a
}
v/100
v=0
for (i in 1:100){
a=kfail(a=1,b=1,n=200,t=0)$persent
v=v+a
}
v/100
v=0
for (i in 1:100){
a=kfail(a=1,b=1,n=200,t=0)$persent
v=v+a
}
v/100
Nkfail=function(a,b,n,N){
rb=rbeta(n = n,shape1 = a,shape2 = b)
list=c()
mtotal=c()
p=0
count=0
#####x=1是代表還未找到做到底的手臂,x=0是代表找到了
x=1
for (i in 1:n){
taget=rb[i]
scount=0
if (length(list)>=n){break}
for (j in 1:n){
if (length(list)>=n){break}
#####在大於N以後，第一次出現F，判斷成功率最高的手臂
if (length(mtotal)>=N & p=="F" & x==1) {taget=rb[which.max(mtotal)];x=0}
ru=runif(n)
###從beta分配抽出來的如果比uniform大，則給S,反之給F
if (taget>=ru[j]) {
p="S"
scount=scount+1
}
else p="F"
###收集每次的實驗結果
list=c(list,p)
if (taget<ru[j] & x==1) {
mtotal=c(mtotal,scount)
break
}
}
}
persent=sum(list=="F")/n
list(list,persent,mtotal)
}
v=rep(0,1000)
for (i in 1:1000){
v[i]=Nkfail(a=1,b=1,n=100,N=50)[[2]]
}
mean(v)
